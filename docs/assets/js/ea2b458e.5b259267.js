"use strict";(self.webpackChunkhowreactworks=self.webpackChunkhowreactworks||[]).push([[794],{7522:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(9901);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),h=o,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||i;return n?a.createElement(m,r(r({ref:t},u),{},{components:n})):a.createElement(m,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2743:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(9901);function o(){return a.createElement("div",{style:{padding:8,textDecoration:"Window"}},a.createElement("i",null,a.createElement("p",null,"This section is not available yet. Please",a.createElement("a",{href:"https://github.com/incepter/how-react-works/issues/new",target:"_blank"}," fill an issue.")),a.createElement("p",null,"While waiting for the newsletter, you can get notified when new content drops by following",a.createElement("a",{href:"https://x.com/incepterr",target:"_blank"}," me on X."))))}},2765:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(3909),o=(n(9901),n(7522)),i=n(2743);const r={sidebar_position:10},l="How hooks work",s={unversionedId:"react-dom/how.hooks.work",id:"react-dom/how.hooks.work",title:"How hooks work",description:"Introduction",source:"@site/docs/react-dom/10.how.hooks.work.md",sourceDirName:"react-dom",slug:"/react-dom/how.hooks.work",permalink:"/how-react-works/docs/react-dom/how.hooks.work",draft:!1,editUrl:"https://github.com/incepter/how-react-works/edit/main/packages/howreactworks/docs/react-dom/10.how.hooks.work.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"reactSidebar",previous:{title:"How Fibers creation works \u23f8\ufe0f",permalink:"/how-react-works/docs/react-dom/how.fiber_creation.works"},next:{title:"How completeWork works",permalink:"/how-react-works/docs/react-dom/how.complete_work.works"}},p={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Context",id:"context",level:2},{value:"<code>ReactCurrentDispatcher</code>",id:"reactcurrentdispatcher",level:2},{value:"How hooks are modelled",id:"how-hooks-are-modelled",level:2},{value:"Hooks examples",id:"hooks-examples",level:3},{value:"How hooks on mount work",id:"how-hooks-on-mount-work",level:2},{value:"<code>mountWorkInProgressHook</code> Implementation",id:"mountworkinprogresshook-implementation",level:3},{value:"How hooks on update work",id:"how-hooks-on-update-work",level:2},{value:"How hooks on rerender work",id:"how-hooks-on-rerender-work",level:2},{value:"How each hook works",id:"how-each-hook-works",level:2},{value:"How use works",id:"how-use-works",level:2},{value:"Signature",id:"signature",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Context",id:"context-1",level:4},{value:"Thenable",id:"thenable",level:4},{value:"Examples",id:"examples",level:3},{value:"How useCallback works",id:"how-usecallback-works",level:2},{value:"Signature",id:"signature-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"On mount",id:"on-mount",level:4},{value:"On Update",id:"on-update",level:4},{value:"How useContext works",id:"how-usecontext-works",level:2},{value:"Signature",id:"signature-2",level:3},{value:"Implementation",id:"implementation-2",level:3},{value:"How Context subscription works",id:"how-context-subscription-works",level:3},{value:"Updates",id:"updates",level:3},{value:"How useEffect works",id:"how-useeffect-works",level:2},{value:"Signature",id:"signature-3",level:3},{value:"Implementation on mount",id:"implementation-on-mount",level:3},{value:"Create the effect object",id:"create-the-effect-object",level:4},{value:"Link the effect to the function component update queue",id:"link-the-effect-to-the-function-component-update-queue",level:4},{value:"Implementation on update",id:"implementation-on-update",level:3},{value:"How useImperativeHandle works",id:"how-useimperativehandle-works",level:2},{value:"Signature",id:"signature-4",level:3},{value:"Implementation on mount",id:"implementation-on-mount-1",level:3},{value:"Implementation on update",id:"implementation-on-update-1",level:3},{value:"How <code>imperativeHandleEffect</code> works",id:"how-imperativehandleeffect-works",level:3},{value:"Signature",id:"signature-5",level:4},{value:"Implementation",id:"implementation-3",level:4},{value:"How useInsertionEffect works",id:"how-useinsertioneffect-works",level:2},{value:"Signature",id:"signature-6",level:3},{value:"Implementation",id:"implementation-4",level:3},{value:"How useLayoutEffect works",id:"how-uselayouteffect-works",level:2},{value:"Signature",id:"signature-7",level:3},{value:"Implementation",id:"implementation-5",level:3},{value:"How useMemo works",id:"how-usememo-works",level:2},{value:"Signature",id:"signature-8",level:3},{value:"Implementation on mount",id:"implementation-on-mount-2",level:3},{value:"Implementation on update",id:"implementation-on-update-2",level:3},{value:"How useReducer works",id:"how-usereducer-works",level:2},{value:"Signature",id:"signature-9",level:3},{value:"Implementation on mount",id:"implementation-on-mount-3",level:3},{value:"How <code>dispatchReducerAction</code> works",id:"how-dispatchreduceraction-works",level:3},{value:"Implementation on update",id:"implementation-on-update-3",level:3},{value:"How useRef works",id:"how-useref-works",level:2},{value:"Signature",id:"signature-10",level:3},{value:"Implementation on mount",id:"implementation-on-mount-4",level:3},{value:"Implementation on update",id:"implementation-on-update-4",level:3},{value:"How useState works",id:"how-usestate-works",level:2},{value:"Signature",id:"signature-11",level:3},{value:"Implementation on mount",id:"implementation-on-mount-5",level:3},{value:"How <code>mountStateImpl</code> works",id:"how-mountstateimpl-works",level:4},{value:"Implementation on update",id:"implementation-on-update-5",level:3},{value:"How useDebugValue works",id:"how-usedebugvalue-works",level:2},{value:"How useDeferredValue works",id:"how-usedeferredvalue-works",level:2},{value:"How useTransition works",id:"how-usetransition-works",level:2},{value:"How useSyncExternalStore works",id:"how-usesyncexternalstore-works",level:2},{value:"How useId works",id:"how-useid-works",level:2},{value:"Annex",id:"annex",level:2}],d={toc:u},c="wrapper";function h(e){let{components:t,...r}=e;return(0,o.kt)(c,(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-hooks-work"},"How hooks work"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/hooks"},"Hooks")," were introduced in React\nv16.8.0, and since then they changed the way React apps were written.\nBefore them, we used to create class component for anything involving state\nor lifecycle logic.\nHooks made function component the new defacto of writing react apps."),(0,o.kt)("p",null,"They were a huge addition that simplified a lot of things. I am not stating here\nthat they are better than class components, but they offer a simpler way\nto reason about components and to deal with them, and especially they allow\nescaping dealing with ",(0,o.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,o.kt)("p",null,"This is not an explanation of React hooks themselves as they are pretty well\ndocumented in the official documentation. We will see how they are written\ninto React."),(0,o.kt)("h2",{id:"context"},"Context"),(0,o.kt)("p",null,"In the previous sections, precisely in how function components get rendered;\nwe've seen that we set a ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatcher")," based on whether your component is\nmounting for the first time or updating. So first, let's demystify this\ndispatcher."),(0,o.kt)("h2",{id:"reactcurrentdispatcher"},(0,o.kt)("inlineCode",{parentName:"h2"},"ReactCurrentDispatcher")),(0,o.kt)("p",null,"in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L556"},(0,o.kt)("inlineCode",{parentName:"a"},"renderWithHooks")),"\nfunction, we set the ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactCurrentDispatcher.current"),". Which is a plain\njavascript object with all the hooks implementations that React has."),(0,o.kt)("p",null,"The goal of having the dispatcher object is to limit the behavior of your hooks'\nusage:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You cannot use hooks outside the render phase: This means that hooks\nwon't work if you just decide to call the function component manually when\nReact isn't rendering. You are probably familiar with the thrown error."),(0,o.kt)("li",{parentName:"ul"},"Hooks behavior on mount and update isn't the same: as we will see later in\nthis section, on mount, the main goal of the dispatcher is to ",(0,o.kt)("inlineCode",{parentName:"li"},"reserve")," as\nplace for your hook call and initialize it, but on update it will perform\nthe update logic which is different.")),(0,o.kt)("p",null,"Like we said, the dispatcher contains as many properties as React hooks:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const AllDispatchers: Dispatcher = {\n  readContext,\n\n  use,\n  useCallback: hook,\n  useContext: hook,\n  useEffect: hook,\n  useImperativeHandle: hook,\n  useInsertionEffect: hook,\n  useLayoutEffect: hook,\n  useMemo: hook,\n  useReducer: hook,\n  useRef: hook,\n  useState: hook,\n  useDebugValue: hook,\n  useDeferredValue: hook,\n  useTransition: hook,\n  useSyncExternalStore: hook,\n  useId: hook,\n};\n")),(0,o.kt)("p",null,"There are several dispatchers, but we will only discuss the main four:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ContextOnlyDispatcher"),": ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3408"},"This dispatcher"),"\nwill prevent you from using hooks outside the render phase. It will throw the\nfamous ",(0,o.kt)("inlineCode",{parentName:"li"},"Invalid hook call")," ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L440"},"error.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"HooksDispatcherOnMount"),": ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3446"},"This dispatcher"),"\ncontains hooks implementation for components when mounting for the first time."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"HooksDispatcherOnUpdate"),": ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3484"},"This dispatcher"),"\ncontains hooks implementation for components when they are updating."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"HooksDispatcherOnRerender"),": ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3522"},"This dispatcher"),"\ncontains hooks implementation when components are re-rendering: when they\nperform a render phase update or when they rendered twice in dev mode.")),(0,o.kt)("h2",{id:"how-hooks-are-modelled"},"How hooks are modelled"),(0,o.kt)("p",null,"Each function component may have calls for any of the supported hooks. Remember,\nall hooks calls occur withing the ",(0,o.kt)("inlineCode",{parentName:"p"},"renderWithHooks")," function (exception for\nthe hooks for re-renders, they are called from within the ",(0,o.kt)("inlineCode",{parentName:"p"},"renderWithHooksAgain"),"\nfunction)."),(0,o.kt)("p",null,"Hooks are store into the ",(0,o.kt)("inlineCode",{parentName:"p"},"memoizedState")," property of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L965"},"related ",(0,o.kt)("inlineCode",{parentName:"a"},"Fiber"),".")),(0,o.kt)("p",null,"A hook is stored inside React as a plain object with the following properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const hook: Hook = {\n  memoizedState: null,\n  \n  baseState: null,\n  baseQueue: null,\n  queue: null,\n  \n  next: null,\n};\n")),(0,o.kt)("p",null,"Where:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState"),': contains the hook "state" (or value)'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"baseState"),": used by state hooks to store the initial value"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"baseQueue"),":"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"queue"),": the UpdateQueue object used by state hooks to store many things"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"next"),": the next hook.")),(0,o.kt)("p",null,"As you may have guessed, the ",(0,o.kt)("inlineCode",{parentName:"p"},"next")," property references in the next hook your\ncomponent uses. Thus, hooks are modelled as a linked list of the previous\ndata structure."),(0,o.kt)("p",null,"Each hook have its own specification when it comes to what it stores inside\nthese properties, some hooks don't use all of these properties, obviously."),(0,o.kt)("p",null,"Notice how this data structure doesn't contain any information about the hook\nbeing used, hooks relies on call order and should ALWAYS be preserved."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"fiber and hook",src:n(4675).Z,width:"671",height:"444"})),(0,o.kt)("p",null,"Dan Abramov wrote an ",(0,o.kt)("a",{parentName:"p",href:"https://overreacted.io/why-do-hooks-rely-on-call-order/"},"outstanding blog post"),"\nexplaining this design choice."),(0,o.kt)("h3",{id:"hooks-examples"},"Hooks examples"),(0,o.kt)("p",null,"Assuming we are rendering the following component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function MyFunctionComponent(props) {\n  const [count, setCount] = React.useState(0);\n  // please don't do this, this is only for demo purposes\n  const isMounted = React.useRef(false);\n  // please don't do this, this is only for demo purposes\n  const mountDate = React.useMemo(() => Date.now(), []);\n  \n  React.useEffect(() => {\n    function handler() {\n      console.log('window is focused')\n    }\n    \n    window.addEventListener(\"focus\", handler);\n    return () => window.removeEventListener(\"focus\", handler);\n  }, []);\n  \n  return <span>Count is {count}</span>\n}\n")),(0,o.kt)("p",null,"Rendering this component will result in having a ",(0,o.kt)("inlineCode",{parentName:"p"},"Fiber")," of tag\n",(0,o.kt)("inlineCode",{parentName:"p"},"FunctionComponent")," with the following hooks linked list:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'let memoizedState = {\n  // useState\n  "memoizedState": 0,\n  "baseState": 0,\n  "baseQueue": null,\n  "queue": {\n    "pending": null,\n    "lanes": 0,\n    "lastRenderedState": 0\n  },\n  "next": {\n    // useRef\n    "memoizedState": {\n      "current": false\n    },\n    "baseState": null,\n    "baseQueue": null,\n    "queue": null,\n    "next": {\n      // useMemo\n      "memoizedState": [\n        1700218172414,\n        []\n      ],\n      "baseState": null,\n      "baseQueue": null,\n      "queue": null,\n      "next": {\n        // useEffect\n        "memoizedState": {\n          "tag": 9,\n          "inst": {},\n          "deps": [],\n          "next": "the same effect .. removed for clarity"\n        },\n        "baseState": null,\n        "baseQueue": null,\n        "queue": null,\n        "next": null\n      }\n    }\n  }\n}\n')),(0,o.kt)("h2",{id:"how-hooks-on-mount-work"},"How hooks on mount work"),(0,o.kt)("p",null,"The purpose on hooks on mount as stated before is to grab a place in the linked\nlist of the hooks."),(0,o.kt)("p",null,"So, all hooks implementations on mount will first perform the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const hook = mountWorkInProgressHook();\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"mountWorkInProgressHook")," function will create the previous data structure\nand then set is as the ",(0,o.kt)("inlineCode",{parentName:"p"},"memoizedState")," property of the ",(0,o.kt)("inlineCode",{parentName:"p"},"currentlyRenderingFiber"),"."),(0,o.kt)("h3",{id:"mountworkinprogresshook-implementation"},(0,o.kt)("inlineCode",{parentName:"h3"},"mountWorkInProgressHook")," Implementation"),(0,o.kt)("p",null,"The mount in progress hook function is implemented as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"First, it will create the hook object"),(0,o.kt)("li",{parentName:"ul"},"Then, if it is the first hook of the list, it will attach it to the\n",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," of the ",(0,o.kt)("inlineCode",{parentName:"li"},"currentlyRenderingFiber")," and set this hook at the\n",(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressHook")),(0,o.kt)("li",{parentName:"ul"},"Or else, it will attach it to the ",(0,o.kt)("inlineCode",{parentName:"li"},"next")," property of the ",(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressHook"),".")),(0,o.kt)("p",null,"And that's it!"),(0,o.kt)("p",null,"Depending on the hook, other things will be performed, we will see them\nseparately for each supported hook."),(0,o.kt)("h2",{id:"how-hooks-on-update-work"},"How hooks on update work"),(0,o.kt)("p",null,"When your component is updating (not its first ever render), each supported\nhook call will start with the following expression then will follow up with\nthe specific work."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const hook = updateWorkInProgressHook();\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L973"},(0,o.kt)("inlineCode",{parentName:"a"},"updateWorkInProgressHook")),"\nis a bit more complex than the mount one, but its purpose it to detect the next\n",(0,o.kt)("inlineCode",{parentName:"p"},"workInProgressHook")," too. it used for both updates and re-renders, so it assumes\nthat there is either a ",(0,o.kt)("inlineCode",{parentName:"p"},"current")," hook object that can be cloned or a\n",(0,o.kt)("inlineCode",{parentName:"p"},"work-in-progress")," from a previous render that can be reused."),(0,o.kt)("p",null,"The first part of this function then is to find the currently rendered hook\nvalue. It will check the ",(0,o.kt)("inlineCode",{parentName:"p"},"current")," rendered fiber's ",(0,o.kt)("inlineCode",{parentName:"p"},"memoizedState"),"\nproperty if the ",(0,o.kt)("inlineCode",{parentName:"p"},"currentHook")," module variable is null, or else it takes its\n",(0,o.kt)("inlineCode",{parentName:"p"},"next")," property:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// at module level:\nlet currentHook: null | Hook = null;\n\n// inside updateWorkInProgressHook\n\nlet nextCurrentHook: null | Hook;\nif (currentHook === null) {\n  // the current rendered fiber\n  const current = currentlyRenderingFiber.alternate;\n  \n  // already mounted\n  if (current !== null) {\n    nextCurrentHook = current.memoizedState;\n  } else {\n    // first mount\n    nextCurrentHook = null;\n  }\n  \n} else {\n  nextCurrentHook = currentHook.next;\n}\n")),(0,o.kt)("p",null,"Now, after detecting the current rendered (painted) hook value, React will\nthen try to find its alternate (the being rendered one):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// at module level:\nlet workInProgressHook: null | Hook = null;\n\n// inside updateWorkInProgressHook\nlet nextWorkInProgressHook: null | Hook;\n\n// first hook of the list, take it from the being rendered fiber\nif (workInProgressHook === null) {\n  nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n} else {\n  // or else, it is the next hook\n  nextWorkInProgressHook = workInProgressHook.next;\n}\n")),(0,o.kt)("p",null,"It is important to note that when we start updating a component, the memoized\nstate property is reset and set to null."),(0,o.kt)("p",null,"Now, we have the currently painted hook value, and the being rendered one."),(0,o.kt)("p",null,"When there is a ",(0,o.kt)("inlineCode",{parentName:"p"},"nextWorkInProgressHook"),", this means that we already have\nstarted rendering then we are rendering again without committing and finishing\nthe render, and thus, we will reuse it as is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (nextWorkInProgressHook !== null) {\n  // There's already a work-in-progress. Reuse it.\n  workInProgressHook = nextWorkInProgressHook;\n  nextWorkInProgressHook = workInProgressHook.next;\n\n  currentHook = nextCurrentHook;\n}\n")),(0,o.kt)("p",null,"Or else, if the ",(0,o.kt)("inlineCode",{parentName:"p"},"nextCurrentHook")," is null, that we are rendering more hooks\nthan the previous render, which is against hooks rules, and then React will\nthrow an error.\nWhen ",(0,o.kt)("inlineCode",{parentName:"p"},"nextCurrentHook")," isn't null, this means that we should clone the previous\nhook and use it as a base:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// React code\n\nif (nextWorkInProgressHook !== null) {\n  // previous code\n} else {\n  if (nextCurrentHook === null) {\n    const currentFiber = currentlyRenderingFiber.alternate;\n    if (currentFiber === null) {\n      // This is the initial render. This branch is reached when the component\n      // suspends, resumes, then renders an additional hook.\n      // Should never be reached because we should switch to the mount dispatcher first.\n      throw new Error(\n              'Update hook called on initial render. This is likely a bug in React. Please file an issue.',\n      );\n    } else {\n      // This is an update. We should always have a current hook.\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n  }\n\n  currentHook = nextCurrentHook;\n\n  // clone from the currently painted hook\n  const newHook: Hook = {\n    memoizedState: currentHook.memoizedState,\n\n    baseState: currentHook.baseState,\n    baseQueue: currentHook.baseQueue,\n    queue: currentHook.queue,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list.\n    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n  } else {\n    // Append to the end of the list.\n    workInProgressHook = workInProgressHook.next = newHook;\n  }\n}\n")),(0,o.kt)("h2",{id:"how-hooks-on-rerender-work"},"How hooks on rerender work"),(0,o.kt)("p",null,"Re-rendering components is an internal term in the React codebase that means\nthat the component either scheduled a render phase update or that we are\nreplaying it in development mode."),(0,o.kt)("p",null,"If you take a close look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"HooksDispatcherOnRerender")," dispatcher, you will\nnotice that it is the same as the ",(0,o.kt)("inlineCode",{parentName:"p"},"HooksDispatcherOnUpdate")," except for:\n",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer: rerenderReducer"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"useState: rerenderState"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"useDeferredValue: rerenderDeferredValue")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useTransition: rerenderTransition"),"."),(0,o.kt)("p",null,"This dispatcher is set from the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L771"},(0,o.kt)("inlineCode",{parentName:"a"},"renderWithHooksAgain")),"\nfunction. I will just copy Andrew's comment about this function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// This is used to perform another render pass. It's used when setState is\n// called during render, and for double invoking components in Strict Mode\n// during development.\n//\n// The state from the previous pass is reused whenever possible. So, state\n// updates that were already processed are not processed again, and memoized\n// functions (`useMemo`) are not invoked again.\n//\n// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\n")),(0,o.kt)("h2",{id:"how-each-hook-works"},"How each hook works"),(0,o.kt)("p",null,"We will follow the presence of hooks in the dispatchers order to explain them."),(0,o.kt)("h2",{id:"how-use-works"},"How use works"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," hook is a new hook that will replace the ",(0,o.kt)("inlineCode",{parentName:"p"},"throw promise")," pattern\nintroduced for suspending components that still wait for data."),(0,o.kt)("p",null,"Suspending using ",(0,o.kt)("inlineCode",{parentName:"p"},"throw promise")," was there since too long, but was never\nofficial, and this hook is introduced as a viable alternative."),(0,o.kt)("h3",{id:"signature"},"Signature"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," hook is ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1093"},"defined here"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function use<T>(usable: Usable<T>): T {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"It accepts either a promise or context type."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The use hook doesn't rely on ",(0,o.kt)("inlineCode",{parentName:"p"},"mountWorkInProgressHook")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"updateWIPHook"),", so\nit can be called conditionally and doesn't obey the rules of hooks.")),(0,o.kt)("h3",{id:"implementation"},"Implementation"),(0,o.kt)("p",null,"As stated before, ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," accepts ",(0,o.kt)("inlineCode",{parentName:"p"},"thenabled")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),":"),(0,o.kt)("h4",{id:"context-1"},"Context"),(0,o.kt)("p",null,"When the provided object to ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," is a React ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),", it will just delegate\nthe work to the ",(0,o.kt)("inlineCode",{parentName:"p"},"readContext")," function. It will be discussed and explained\nin the ",(0,o.kt)("inlineCode",{parentName:"p"},"useContext")," section."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (\n  usable.$$typeof === REACT_CONTEXT_TYPE ||\n  usable.$$typeof === REACT_SERVER_CONTEXT_TYPE\n) {\n  const context: ReactContext<T> = usable;\n  return readContext(context);\n}\n")),(0,o.kt)("p",null,"So, ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," will allow you to conditionally subscribe to a context while escaping\nthe rules of hooks \ud83e\udd2f"),(0,o.kt)("h4",{id:"thenable"},"Thenable"),(0,o.kt)("p",null,"When a thenable object is provided, React will call the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1066"},"internal ",(0,o.kt)("inlineCode",{parentName:"a"},"useThenable")),"\nfunction:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function use<T>(usable: Usable<T>): T {\n  if (usable !== null && typeof usable === 'object') {\n    if (typeof usable.then === 'function') {\n      const thenable: Thenable<T> = usable;\n      return useThenable(thenable);\n    }\n    // ... other code\n  }\n\n  throw new Error('An unsupported type was passed to use(): ' + String(usable));\n}\n")),(0,o.kt)("p",null,"We've reached a point where the ",(0,o.kt)("inlineCode",{parentName:"p"},"useThenable")," function is clearly behind\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," hook's work:"),(0,o.kt)("p",null,"Besides of initializing and incrementing the thenable state (which I will not\nexplain now), useThenable calls ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberThenable.js#L69"},(0,o.kt)("inlineCode",{parentName:"a"},"trackUsedThenable")),"\nwhich will do the whole work."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useThenable<T>(thenable: Thenable<T>): T {\n  // Track the position of the thenable within this fiber.\n  const index = thenableIndexCounter;\n  thenableIndexCounter += 1;\n  if (thenableState === null) {\n    // createThenableState returns a plain javascript array\n    thenableState = createThenableState();\n  }\n  // highlight-next-line\n  const result = trackUsedThenable(thenableState, thenable, index);\n  // ... other code\n  return result;\n}\n\n")),(0,o.kt)("p",null,"Let's then dive into ",(0,o.kt)("inlineCode",{parentName:"p"},"trackUsedThenable"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Part 1: Add the thenable to the array of thenables:"),(0,o.kt)("p",{parentName:"li"},"Please pay attention to Sophie's comment: if the there was a thenable at\nthe same position, we will reuse the former one because they should\ntechnically point to the same value. Don't ask me of this design choice."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const previous = thenableState[index];\n  if (previous === undefined) {\n    thenableState.push(thenable);\n  } else {\n    if (previous !== thenable) {\n      // Reuse the previous thenable, and drop the new one. We can assume\n      // they represent the same value, because components are idempotent.\n\n      // Avoid an unhandled rejection errors for the Promises that we'll\n      // intentionally ignore.\n      thenable.then(noop, noop);\n      thenable = previous;\n    }\n  }\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Part 2: Track the thenable\nThere are two cases, whether we previously tracked this thenable, or it is\nthe first time we encounter it."),(0,o.kt)("p",{parentName:"li"},"Tracking the thenable is adding a ",(0,o.kt)("inlineCode",{parentName:"p"},"then(onFullfilement, onRejection)"),"\ncallbacks that will mutate the thenable itself:"),(0,o.kt)("p",{parentName:"li"},"Read well the following code and grasp it:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const pendingThenable: PendingThenable<T> = thenable;\npendingThenable.status = 'pending';\npendingThenable.then(\n  fulfilledValue => {\n    if (thenable.status === 'pending') {\n      const fulfilledThenable: FulfilledThenable<T> = thenable;\n      fulfilledThenable.status = 'fulfilled';\n      fulfilledThenable.value = fulfilledValue;\n    }\n  },\n  (error: mixed) => {\n    if (thenable.status === 'pending') {\n      const rejectedThenable: RejectedThenable<T> = thenable;\n      rejectedThenable.status = 'rejected';\n      rejectedThenable.reason = error;\n    }\n  },\n);\n")),(0,o.kt)("p",{parentName:"li"},"But before tracking like this, if the thenable was already tracked, we only\nverify its status:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"switch (thenable.status) {\n  case 'fulfilled': {\n    const fulfilledValue: T = thenable.value;\n    return fulfilledValue;\n  }\n  case 'rejected': {\n    const rejectedError = thenable.reason;\n    checkIfUseWrappedInAsyncCatch(rejectedError);\n    throw rejectedError;\n  }\n  // ... other code\n}\n")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"When status is ",(0,o.kt)("inlineCode",{parentName:"li"},"fulfilled"),", the ",(0,o.kt)("inlineCode",{parentName:"li"},"use")," hook will return the value"),(0,o.kt)("li",{parentName:"ul"},"When status is ",(0,o.kt)("inlineCode",{parentName:"li"},"rejected"),", the ",(0,o.kt)("inlineCode",{parentName:"li"},"use")," hook will throw the error")),(0,o.kt)("p",{parentName:"li"},"When the status is ",(0,o.kt)("inlineCode",{parentName:"p"},"pending"),", React will throw a special exception object\ncalled ",(0,o.kt)("inlineCode",{parentName:"p"},"SuspenseException")," to suspend the tree until the thenable resolves\nor rejects."),(0,o.kt)("p",{parentName:"li"},"This will lead to the component rendering only if it has data, and throwing\nin the other cases."),(0,o.kt)("admonition",{parentName:"li",type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The use hook will require you to put an Error boundary in the tree to\nintercept rejections.")))),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," hook will require you to manually cache/memoize the promises."),(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"React.cache")," experimental API is designed to help you with that.")),(0,o.kt)("h3",{id:"examples"},"Examples"),(0,o.kt)("p",null,"Let's say we want to get the user details from the public jsonplaceholder API."),(0,o.kt)("p",null,"To achieve that, we will create a small cache to help us memoizing the promises\nand thus avoid infinite renders. So, let's create a dumb memoizer for functions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// we assume that we will cache with one parameter\n// which will be the user id.\n// React.cache is a general solution for this.\n// for clarity, we'll use only userId\nfunction createCache(asyncFunc) {\n  let cache = {};\n\n  return function exec(...args) {\n    let cacheId = args[0];\n    let existing = cache[cacheId];\n    if (existing) {\n      return existing;\n    }\n\n    let result = asyncFunc.apply(null, args);\n    cache[cacheId] = result;\n    return result;\n  };\n}\n")),(0,o.kt)("p",null,"Let's then create a dumb error boundary for that too:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"class ErrorBoundary extends React.Component {\n  state = { error: null };\n  componentDidCatch(error) {\n    this.setState((prev) => ({ ...prev, error }));\n  }\n  render() {\n    const { error } = this.state;\n    if (error) {\n      return (\n        <>\n          <pre>{error.toString()}</pre>\n          <button\n            onClick={() => this.setState((prev) => ({ ...prev, error: null }))}\n          >\n            Reset\n          </button>\n        </>\n      );\n    }\n    return this.props.children;\n  }\n}\n")),(0,o.kt)("p",null,"And finally, let's exploit this code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'async function fetchUserById(userId) {\n  let result = await axios.get(\n    `https://jsonplaceholder.typicode.com/users/${userId}`\n  );\n  return result.data;\n}\n\nlet getUserDetails = createCache(fetchUserById);\n\nlet IDS = [1, 2, 3, 4, 5, 10, 11];\n\nfunction UserDetails({ id }) {\n  let details = React.use(getUserDetails(id));\n\n  return (\n    <details open>\n      <pre>{JSON.stringify(details, null, 4)}</pre>\n    </details>\n  );\n}\nfunction Example() {\n  let [userId, setUserId] = React.useState(IDS[0]);\n  return (\n    <div className="App">\n      {IDS.map((id) => (\n        <button\n          onClick={() => {\n            setUserId(id);\n          }}\n          key={id}\n        >\n          {`User ${id}`}\n        </button>\n      ))}\n      <React.Suspense fallback={`Loading user ${userId}`}>\n        <UserDetails id={userId} />\n      </React.Suspense>\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <ErrorBoundary>\n      <Example />\n    </ErrorBoundary>\n  );\n}\n')),(0,o.kt)("p",null,"You can view and manipulate this ",(0,o.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/lucid-curran-x8xxlj?file=/src/App.js"},"demo here:")),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/lucid-curran-x8xxlj?fontsize=14&hidenavigation=1&theme=dark",style:{width:"100%",height:"500px",border:0,borderRadius:4},title:"React.use demo",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,o.kt)("h2",{id:"how-usecallback-works"},"How useCallback works"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback")," hook allows you to keep a function reference until\na dependency changes."),(0,o.kt)("h3",{id:"signature-1"},"Signature"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useCallback")," is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"The previous function doesn't exist directly, as stated before, there is\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2602"},(0,o.kt)("inlineCode",{parentName:"a"},"mountCallback")," "),"\nand ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2609"},(0,o.kt)("inlineCode",{parentName:"a"},"updateCallback")),"\nfunctions, with the same signature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  // [Not Native Code]\n}\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  // [Not Native Code]\n}\n")),(0,o.kt)("h3",{id:"implementation-1"},"Implementation"),(0,o.kt)("h4",{id:"on-mount"},"On mount"),(0,o.kt)("p",null,"When your component renders for the first time while using ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback"),", the\ncall will be intercepted by ",(0,o.kt)("inlineCode",{parentName:"p"},"mountCallback"),", which is probably the easiest hook:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  // step 1\n  // highlight-next-line\n  const hook = mountWorkInProgressHook();\n  // step 2\n  // highlight-next-line\n  const nextDeps = deps === undefined ? null : deps;\n  // step 3\n  // highlight-next-line\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": Mount the hook data structure seen in the top of this section"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": Define the dependencies to use, if the parameter is omitted, ",(0,o.kt)("inlineCode",{parentName:"li"},"null"),"\nis used."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": Store the callback and dependencies in the ",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," of the\nhook.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useCallback")," will return whatever value you throw at it, usually we give either\nan inline function defined directly there, or a function defined in the component\nbody."),(0,o.kt)("p",null,"So, in mount, useCallback don't care about your dependencies, it will only\nstore them for later usage."),(0,o.kt)("h4",{id:"on-update"},"On Update"),(0,o.kt)("p",null,"On updates, the goal is to give you a new function reference ",(0,o.kt)("strong",{parentName:"p"},"only")," if\none dependency changes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  // step 1\n  // highlight-next-line\n  const hook = updateWorkInProgressHook();\n  // step 2\n  // highlight-next-line\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  // step 3\n  // highlight-next-line\n  if (nextDeps !== null) {\n    const prevDeps: Array<mixed> | null = prevState[1];\n    // step 4\n    // highlight-next-line\n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      return prevState[0];\n    }\n  }\n  // step 5\n  // highlight-next-line\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": Create or reuse the hook data structure object."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": Infer the dependencies array, or ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," if nothing is provided."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": When dependencies aren't null, which means that we are memoizing\nthings (undefined as second argument means that we won't memoize anything), we\nwill proceed to compare them with the previous deps."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": This compares the previous and next dependencies, if they are\nthe same, the previous value (the first element in the ",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," array)\nis returned. We'll see the comparison in a few."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 5"),": When dependencies changed or that we aren't using them, similarly\nto ",(0,o.kt)("inlineCode",{parentName:"li"},"mountCallback"),", we store ",(0,o.kt)("inlineCode",{parentName:"li"},"[callback, nextDeps]")," into the ",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState"),"\nproperty of the hook object.")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L451"},(0,o.kt)("inlineCode",{parentName:"a"},"areHookInputsEqual")),"\nfunction is used in all hooks that use the dependencies array. It will:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Always ",(0,o.kt)("inlineCode",{parentName:"li"},"return")," false when there are no previous dependencies, which instructs\nReact to recompute the hook returned value. In human words, this means that\nour hook doesn't use any dependencies and will be refreshed every render."),(0,o.kt)("li",{parentName:"ul"},"Loop over both arrays and use ",(0,o.kt)("inlineCode",{parentName:"li"},"Object.is")," to compare individual values.")),(0,o.kt)("h2",{id:"how-usecontext-works"},"How useContext works"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useContext"},(0,o.kt)("inlineCode",{parentName:"a"},"useContext")," hook")," allows you\nto read and subscribe to a ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/@mohamedelayadi/react-context-all-you-need-to-know-40de6662b074"},"React Context"),"\nvalue."),(0,o.kt)("h3",{id:"signature-2"},"Signature"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L713"},(0,o.kt)("inlineCode",{parentName:"a"},"useContext")," hook"),"\nis defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function readContext<T>(context: ReactContext<T>): T {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"Where the unique parameter refers to a React context object created by the\n",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/createContext"},(0,o.kt)("inlineCode",{parentName:"a"},"React.createContext")," API.")),(0,o.kt)("h3",{id:"implementation-2"},"Implementation"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useContext")," uses the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L740"},(0,o.kt)("inlineCode",{parentName:"a"},"readContextForConsumer")),"\nfunction:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export function readContext<T>(context: ReactContext<T>): T {\n  // ...dev checks\n  return readContextForConsumer(currentlyRenderingFiber, context);\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"readContextForConsumer")," is responsible for giving you the current context\nvalue and also subscribe to it for future changes. Let's dig into its\nimplementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function readContextForConsumer<T>(\n  consumer: Fiber | null,\n  context: ReactContext<T>,\n): T {\n  \n  // step 1\n  // highlight-next-line\n  const value = isPrimaryRenderer\n    ? context._currentValue\n    : context._currentValue2;\n\n  // step 2\n  // highlight-next-line\n  if (lastFullyObservedContext === context) {\n    // Nothing to do. We already observe everything in this context.\n\n  // step 3\n  // highlight-next-line\n  } else {\n    \n  }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": Decides on the internal context value based on the\n",(0,o.kt)("inlineCode",{parentName:"li"},"isPrimaryRenderer")," renderer property. I don't have much experience with this\nproperty, but you set it while creating a custom React renderer. Primary means\nthat your renderer renders the whole page, and secondary means that you are\nwriting a renderer meant to be used on top of another one. In our case, which\nis React-DOM, it is a primary renderer, so we take the ",(0,o.kt)("inlineCode",{parentName:"li"},"_currentValue")," value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": The second step will actually bail out reading and subscribing to\nthis context. React uses the ",(0,o.kt)("inlineCode",{parentName:"li"},"lastFullyObservedContext")," module variable, which\n",(0,o.kt)("a",{parentName:"li",href:"https://github.com/search?q=repo%3Afacebook%2Freact%20lastFullyObservedContext&type=code"},"seems to be unused"),".\nI mean, I haven't seen it being written in the whole codebase."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": The third step is where subscription occurs, let's dig into it.")),(0,o.kt)("h3",{id:"how-context-subscription-works"},"How Context subscription works"),(0,o.kt)("p",null,"The context subscription is stored in the ",(0,o.kt)("inlineCode",{parentName:"p"},"fiber.dependencies")," property in\na linked list fashion (again):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nfunction readContextForConsumer<T>(\n  consumer: Fiber | null,\n  context: ReactContext<T>,\n): T {\n  const value = context._currentValue;\n\n  const contextItem = {\n    context: (context as ReactContext<any>),\n    memoizedValue: value,\n    next: null,\n  };\n}\n")),(0,o.kt)("p",null,"Then, when this is the first ",(0,o.kt)("inlineCode",{parentName:"p"},"useContext")," in this component, it will add the\nfollowing object as ",(0,o.kt)("inlineCode",{parentName:"p"},"dependencies"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\n\n// the lastContextDependency variable is reset in the prepareToReadContext\n// function called when we are about to update components\n// (updateFunctionComponent and others)\nif (lastContextDependency === null) {\n  lastContextDependency = contextItem;\n  // consumer is the work in progress fiber\n  consumer.dependencies = {\n    lanes: NoLanes,\n    firstContext: contextItem\n  }\n}\n")),(0,o.kt)("p",null,"Or else, it will add the context item as the ",(0,o.kt)("inlineCode",{parentName:"p"},"next")," property of the previous one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (lastContextDependency === null) {\n  // ...\n} else {\n  lastContextDependency = lastContextDependency.next = contextItem;\n}\n")),(0,o.kt)("p",null,"And that's it!"),(0,o.kt)("h3",{id:"updates"},"Updates"),(0,o.kt)("p",null,"When a component rendering a ",(0,o.kt)("inlineCode",{parentName:"p"},"ContextProvider")," gets updated, React will check\non the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," ",(0,o.kt)("inlineCode",{parentName:"p"},"prop"),", and if it changed, it will propagate the changes."),(0,o.kt)("p",null,"This section will be explained in how rendering of a ",(0,o.kt)("inlineCode",{parentName:"p"},"ContextProvider")," works."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Similarly to the ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," hook, ",(0,o.kt)("inlineCode",{parentName:"p"},"useContext")," can be called conditionally on render."),(0,o.kt)("p",{parentName:"admonition"},"But you cannot call it inside other hooks or outside the render phase. Because\nit needs the currently rendering fiber to be able to perform subscription.")),(0,o.kt)("h2",{id:"how-useeffect-works"},"How useEffect works"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useEffect"},"The ",(0,o.kt)("inlineCode",{parentName:"a"},"useEffect")," hook")," allows you\nto register passive effects on your component."),(0,o.kt)("p",null,"Passive effects run as the last part of the ",(0,o.kt)("inlineCode",{parentName:"p"},"commit")," phase of the render.\nIt is either synchronous for ",(0,o.kt)("inlineCode",{parentName:"p"},"SyncLane"),"s for ",(0,o.kt)("inlineCode",{parentName:"p"},"Asynchronous")," for the rest lanes."),(0,o.kt)("p",null,"From the docs:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"useEffect is a React Hook that lets you synchronize a component with an\nexternal system.")),(0,o.kt)("p",null,"This means that you should ",(0,o.kt)("strong",{parentName:"p"},"only")," use this hook to keep your component in sync\nwith external systems, such as the browser APIs (focus, resize, blur...) or\nsome external stores."),(0,o.kt)("h3",{id:"signature-3"},"Signature"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," hooks is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"It accepts two parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"create"),": the effect creation function, it doesn't accept any parameters, and\nreturn either nothing, or a ",(0,o.kt)("inlineCode",{parentName:"li"},"cleanup")," function. The cleanup function is\nresponsible for cleaning the effect work: such as unsubscribing from an event."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"deps"),": The optional dependencies array, that will result in running the\neffect creation again whenever a dependency changes. If this parameter is\nomitted, the effect will run at ",(0,o.kt)("strong",{parentName:"li"},"the end of every render phase."))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"If your component performs a render phase state update, the effect won't run\ntwice. But rather, the effects are ran at the commit phase, after the render is\nperformed.")),(0,o.kt)("h3",{id:"implementation-on-mount"},"Implementation on mount"),(0,o.kt)("p",null,"Like normal hooks, this hook relies on ",(0,o.kt)("inlineCode",{parentName:"p"},"mountWorkInProgressHook()"),", which\ncreates the object seen in the start of this section.\n",(0,o.kt)("inlineCode",{parentName:"p"},"mountEffect")," calls a function called ",(0,o.kt)("inlineCode",{parentName:"p"},"mountEffectImpl"),"."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"mountEffectImpl")," is called from all the other effect hooks (",(0,o.kt)("inlineCode",{parentName:"p"},"useLayoutEffect"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"useInsertionEffect")," and other hooks that add special effects.)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  mountEffectImpl(\n    PassiveEffect | PassiveStaticEffect,\n    HookPassive,\n    create,\n    deps,\n  );\n}\n")),(0,o.kt)("p",null,"Let's discuss the previous snippet before going any longer, to do so, we need\nto observe the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2331"},(0,o.kt)("inlineCode",{parentName:"a"},"mountEffectImpl")," signature:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountEffectImpl(\n  fiberFlags: Flags,\n  hookFlags: HookFlags,\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  // [Not Native Code]\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"fiberFlags"),": Flags that will be added to the component using the effect"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"hookFlags"),": Flags that define ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/9cdf8a99edcfd94d7420835ea663edca04237527/packages/react-reconciler/src/ReactHookEffectTags.js#L10"},"the effect itself"),",\npossible values are: ",(0,o.kt)("inlineCode",{parentName:"li"},"Insertion"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Layout")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Passive"),". ",(0,o.kt)("inlineCode",{parentName:"li"},"Passive")," is used\nfor ",(0,o.kt)("inlineCode",{parentName:"li"},"useEffect"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"create"),": The effect function"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"deps"),": The effect dependencies")),(0,o.kt)("p",null,"Finally, let's take a look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffectImpl")," function before diving more\nin this maze:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountEffectImpl(\n  fiberFlags: Flags,\n  hookFlags: HookFlags,\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  // step 1\n  // highlight-next-line\n  const hook = mountWorkInProgressHook();\n  // step 2\n  // highlight-next-line\n  const nextDeps = deps === undefined ? null : deps;\n  // step 3\n  // highlight-next-line\n  currentlyRenderingFiber.flags |= fiberFlags;\n  // step 4\n  // highlight-next-line\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    createEffectInstance(),\n    nextDeps,\n  );\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": Mount the hook data structure seen in the top of this section"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": Define the dependencies to use, if the parameter is omitted, ",(0,o.kt)("inlineCode",{parentName:"li"},"null"),"\nis used."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": Add the received fiberFlags to the currently rendering fiber. In\nthe case of ",(0,o.kt)("inlineCode",{parentName:"li"},"useEffect"),", it is: ",(0,o.kt)("inlineCode",{parentName:"li"},"PassiveEffect | PassiveStaticEffect"),", which\nis a natural number (",(0,o.kt)("inlineCode",{parentName:"li"},"8390656")," at the moment of writing these words)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": Store the ",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," value of this hook, which is the result\nof calling the ",(0,o.kt)("inlineCode",{parentName:"li"},"pushEffect"),".")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2236"},(0,o.kt)("inlineCode",{parentName:"a"},"createEffectInstance")," function"),"\njust returns the object ",(0,o.kt)("inlineCode",{parentName:"p"},"{ destroy: undefined }"),". It will be used to store the\neffect cleanup function (if any)."),(0,o.kt)("p",null,"So, the last part of this is to take a look at the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2202"},(0,o.kt)("inlineCode",{parentName:"a"},"pushEffect")," function:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function pushEffect(\n  tag: HookFlags, // useEffect: Passive\n  create: () => (() => void) | void,\n  inst: EffectInstance, // { destroy: undefined }\n  deps: Array<mixed> | null,\n): Effect {\n  // [Not Native Code]\n}\n")),(0,o.kt)("h4",{id:"create-the-effect-object"},"Create the effect object"),(0,o.kt)("p",null,"This object is created every render for every effect you use, it stores the\nrelevant information needed to perform well."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const effect: Effect = {\n  tag, // The hook flag\n  create, // the provided effect function\n  inst, // { destroy: undefined }\n  deps, // the provided dependencies or null\n  // Circular\n  next: null, // this will be set next\n};\n")),(0,o.kt)("h4",{id:"link-the-effect-to-the-function-component-update-queue"},"Link the effect to the function component update queue"),(0,o.kt)("p",null,"Next, React will reference the ",(0,o.kt)("inlineCode",{parentName:"p"},"currentlyRenderingFiber.updateQueue")," property,\nand if null, it will initialize it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"let componentUpdateQueue: null | FunctionComponentUpdateQueue =\n  currentlyRenderingFiber.updateQueue;\nif (componentUpdateQueue === null) {\n  componentUpdateQueue = createFunctionComponentUpdateQueue();\n  currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n  // this creates a circular reference (it will be teared a part when committing)\n  componentUpdateQueue.lastEffect = effect.next = effect;\n}\n")),(0,o.kt)("p",null,"The update queue created by ",(0,o.kt)("inlineCode",{parentName:"p"},"createFunctionComponentUpdateQueue")," looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const updateQueue = {\n  lastEffect: null,\n  events: null,\n  stores: null,\n}\n\n// when the memoCache feature is enabled, it will add a memoCache property\n// initialized by null\n")),(0,o.kt)("p",null,"It is used as a circular linkedList, when we store the lastEffect (its ",(0,o.kt)("inlineCode",{parentName:"p"},"next"),"\nproperty will then point to the ",(0,o.kt)("inlineCode",{parentName:"p"},"first")," effect in the list.)"),(0,o.kt)("p",null,"When the component ",(0,o.kt)("inlineCode",{parentName:"p"},"updateQueue")," is already initialized (we've called an\neffect before in this render, or another hook initialized it), React will take\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"lastEffect")," property and:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," (may happen if the updateQueue was initialized by events or stores\nand not by an effect), it will do the same as before: will create a circular\nreference by the ",(0,o.kt)("inlineCode",{parentName:"li"},"effect")," object and itself, and store it in the ",(0,o.kt)("inlineCode",{parentName:"li"},"lastEffect"),"\nproperty of the queue.",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const lastEffect = componentUpdateQueue.lastEffect;\nif (lastEffect === null) {\n  componentUpdateQueue.lastEffect = effect.next = effect;\n} else {\n    // take a look next\n}\n"))),(0,o.kt)("li",{parentName:"ul"},"Not ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," means that we called an effect hook before in this render pass,\nand in this case, React will execute this code:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const firstEffect = lastEffect.next;\nlastEffect.next = effect;\neffect.next = firstEffect;\ncomponentUpdateQueue.lastEffect = effect;\n")),"Don't be confused, let's break the previous code:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"First, reference the first effect on the list (well, since it is a circular\nlinked list, the first is the ",(0,o.kt)("inlineCode",{parentName:"li"},"next")," of the last)."),(0,o.kt)("li",{parentName:"ul"},"Add the new effect as the ",(0,o.kt)("inlineCode",{parentName:"li"},"next")," of the previous ",(0,o.kt)("inlineCode",{parentName:"li"},"lastEffect"),": well, this is\nthe new last."),(0,o.kt)("li",{parentName:"ul"},"The new effect (which is the new last) will point then to the ",(0,o.kt)("inlineCode",{parentName:"li"},"firstEffect"),"\nin its ",(0,o.kt)("inlineCode",{parentName:"li"},"next")," property."),(0,o.kt)("li",{parentName:"ul"},"Finally, mark the new effect as the lastEffect in the list in the component\n",(0,o.kt)("inlineCode",{parentName:"li"},"updateQueue"),".")))),(0,o.kt)("p",null,"Finally, the ",(0,o.kt)("inlineCode",{parentName:"p"},"pushEffect")," function will return the new effect object defined\nbelow and store it in the ",(0,o.kt)("inlineCode",{parentName:"p"},"hook.memoizedState"),"."),(0,o.kt)("h3",{id:"implementation-on-update"},"Implementation on update"),(0,o.kt)("p",null,"On updates, ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," will ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2407"},"call ",(0,o.kt)("inlineCode",{parentName:"a"},"updateEffect")),"\nfrom the",(0,o.kt)("inlineCode",{parentName:"p"},"HooksDispatcherOnUpdate")," dispatcher, which will delegate to the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2348"},(0,o.kt)("inlineCode",{parentName:"a"},"updateEffectImpl")," function"),"."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"These functions have the same signature as the mount ones."),(0,o.kt)("p",{parentName:"admonition"},"The only difference to note is the passed ",(0,o.kt)("inlineCode",{parentName:"p"},"fiberFlags"),": On mount we passed\n",(0,o.kt)("inlineCode",{parentName:"p"},"PassiveEffect | PassiveStaticEffect"),", and on update we pass only ",(0,o.kt)("inlineCode",{parentName:"p"},"PassiveEffect"),"."),(0,o.kt)("p",{parentName:"admonition"},"At the moment of writing these words, I cannot seem to know what causes this\ndifference, I cannot find any place in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/search?q=repo%3Afacebook%2Freact%20PassiveStatic&type=code"},"the React codebase"),"\nwhere the",(0,o.kt)("inlineCode",{parentName:"p"},"PassiveStaticEffect")," is used to build any decision. Apart from some\ntodos, so maybe an incoming/unfinished feature."),(0,o.kt)("p",{parentName:"admonition"},"But there is also the following comment where static ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/768f965de2d4c6be7f688562ef02382478c82e5b/packages/react-reconciler/src/ReactFiberFlags.js#L59"},"flags are declared:")),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nexport const RefStatic = /*                    */ 0b0000001000000000000000000000;\nexport const LayoutStatic = /*                 */ 0b0000010000000000000000000000;\nexport const PassiveStatic = /*                */ 0b0000100000000000000000000000;\nexport const MaySuspendCommit = /*             */ 0b0001000000000000000000000000;\n"))),(0,o.kt)("p",null,"In addition to passed parameters, the implementation surely differ, because\non updates, we need to check if dependencies changed:"),(0,o.kt)("p",null,"So, first, the ",(0,o.kt)("inlineCode",{parentName:"p"},"updatewWorkInProgressHook")," function is called."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function updateEffectImpl(\n  fiberFlags: Flags, // PassiveEffect\n  hookFlags: HookFlags, // HookPassive for useEffect\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  // the effect from the previous render\n  const effect: Effect = hook.memoizedState;\n  // the effect instance from the previous render, it will be reused\n  const inst = effect.inst;\n\n  // currentHook is null on initial mount when rerendering after a render phase\n  // state update or for strict mode.\n  // we've seen currentHook at the start of this section, in updateWIPHook\n  if (currentHook !== null) {\n    if (nextDeps !== null) {\n      const prevEffect: Effect = currentHook.memoizedState;\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        // pushEffect was described on mount above, we call it here too\n        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);\n        return;\n      }\n    }\n  }\n\n  // add the fiberFlags to the fiber.flags\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    inst,\n    nextDeps,\n  );\n}\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"This is how useEffect works, the effect functions are executed in the commit\nphase. During render, we just store the relevant information."),(0,o.kt)("p",{parentName:"admonition"},"Please refer to the ",(0,o.kt)("a",{parentName:"p",href:"/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works"},(0,o.kt)("inlineCode",{parentName:"a"},"how commit works")," section"),"\nfor more information about the timing of invocation of each type of effects.")),(0,o.kt)("h2",{id:"how-useimperativehandle-works"},"How useImperativeHandle works"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useImperativeHandle"},(0,o.kt)("inlineCode",{parentName:"a"},"useImperativeHandle")," hook"),"\nis defined in the official docs as:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"useImperativeHandle is a React Hook that lets you customize the handle exposed\nas a ref.")),(0,o.kt)("p",null,"In human words for the rest of us, this means that it lets you override what\na component is exposing as ref (the handle), for example, if you want to add a\nfunction to your custom button, let's say, you want to add a ",(0,o.kt)("inlineCode",{parentName:"p"},"sayHiTo(name)"),"\nfunction to it that will show an ",(0,o.kt)("inlineCode",{parentName:"p"},"alert"),", and so on."),(0,o.kt)("h3",{id:"signature-4"},"Signature"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useImerativeHandle")," is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  // [Not Native Code]\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"ref"),": The ref, created by ",(0,o.kt)("inlineCode",{parentName:"li"},"useRef")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"createRef"),", can be also a ref\ncallback"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"create"),": The function that will return the new ref '",(0,o.kt)("inlineCode",{parentName:"li"},"handle"),"'"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"deps"),": The hook dependencies, the create function will be called again\nwhen a dependency changes.")),(0,o.kt)("h3",{id:"implementation-on-mount-1"},"Implementation on mount"),(0,o.kt)("p",null,"When the component using ",(0,o.kt)("inlineCode",{parentName:"p"},"useImperativeHandle")," renders for the first time,\nit will call the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2533"},(0,o.kt)("inlineCode",{parentName:"a"},"mountImperativeHandle")," function"),"\nwhich is implemented as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// step 1\n// highlight-next-line\nconst effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n// step 2\n// highlight-next-line\nmountEffectImpl(\n  UpdateEffect | LayoutStaticEffect,\n  HookLayout,\n  imperativeHandleEffect.bind(null, create, ref),\n  effectDeps,\n);\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": Compute the real hook dependencies: The provided ones in addition\nto the ref object itself. Maybe we can skip adding the ref to the array and\nsuppose the developer should add it manually ? But this won't be backward\ncompatible anyway."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": The second step is to mount an effect (wait! what ? \ud83d\ude33)")),(0,o.kt)("p",null,"Yes, you've read that right, ",(0,o.kt)("inlineCode",{parentName:"p"},"useImperativeHandle")," will insert a special layout\neffect whose ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," function is the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2503"},(0,o.kt)("inlineCode",{parentName:"a"},"imperativeHandleEffect")," function")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"During the commit phase, React will attach refs at the ",(0,o.kt)("inlineCode",{parentName:"p"},"Layout")," phase. That's\nwhy the whole work is used as a layout effect.")),(0,o.kt)("h3",{id:"implementation-on-update-1"},"Implementation on update"),(0,o.kt)("p",null,"On updates, ",(0,o.kt)("inlineCode",{parentName:"p"},"useImperativeHandle")," will calculate the deps like on mount,\nand then call to ",(0,o.kt)("inlineCode",{parentName:"p"},"updateEffectImpl")," with only ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateEffect")," as fiber flags."),(0,o.kt)("p",null,"This brings us to the real work."),(0,o.kt)("h3",{id:"how-imperativehandleeffect-works"},"How ",(0,o.kt)("inlineCode",{parentName:"h3"},"imperativeHandleEffect")," works"),(0,o.kt)("h4",{id:"signature-5"},"Signature"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n): void | (() => void) {\n  // [Not Native Code]\n}\n")),(0,o.kt)("h4",{id:"implementation-3"},"Implementation"),(0,o.kt)("p",null,"The implementation will perform the work based on whether the passed ref is\na ref object or a ref callback, and either ways will call your passed ",(0,o.kt)("inlineCode",{parentName:"p"},"create"),"\nfunction and return a cleanup function for the layout effect:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (typeof ref === 'function') {\n  // step 1\n  // highlight-next-line\n  const refCallback = ref;\n  // step 2\n  // highlight-next-line\n  const inst = create();\n  // step 3\n  // highlight-next-line\n  refCallback(inst);\n  // step 4\n  // highlight-next-line\n  return () => {\n    refCallback(null);\n  };\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": keep track of the passed ref callback reference"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": call the useImperativeHandle create function, that will produce\nthe new ref handle"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": call the ref callback with the resulting handle"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": return the layout effect cleanup to call the ref callback again\nwith a null value")),(0,o.kt)("p",null,"Alternatively, when the passed ",(0,o.kt)("inlineCode",{parentName:"p"},"ref")," is a ",(0,o.kt)("inlineCode",{parentName:"p"},"refObject"),", then\n",(0,o.kt)("inlineCode",{parentName:"p"},"imperativeHandleEffect")," will:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// this is origannly an else if\nif (ref !== null && ref !== undefined) {\n  // step 1\n  // highlight-next-line\n  const refObject = ref;\n  // step 2\n  // highlight-next-line\n  const inst = create();\n  // step 3\n  // highlight-next-line\n  refObject.current = inst;\n  // step 4\n  // highlight-next-line\n  return () => {\n    refObject.current = null;\n  };\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": keep track of the passed ref object reference"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": call the useImperativeHandle create function, that will produce\nthe new ref handle"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": attach the resulting ref handle to the ",(0,o.kt)("inlineCode",{parentName:"li"},"current")," property of the\nref object"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": return the layout effect cleanup that will reset the ",(0,o.kt)("inlineCode",{parentName:"li"},"current"),"\nproperty to null")),(0,o.kt)("p",null,"And that's it!"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"As stated before, the ",(0,o.kt)("inlineCode",{parentName:"p"},"imperativeHandleEffect")," will be invoked during the\nlayout effect iteration of the commit phase. It won't be called right away\nduring render.")),(0,o.kt)("h2",{id:"how-useinsertioneffect-works"},"How useInsertionEffect works"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useInsertionEffect"},(0,o.kt)("inlineCode",{parentName:"a"},"useInsertionEffect")," hook"),"\nby definition:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Allows inserting elements into the DOM before any layout effects fire")),(0,o.kt)("p",null,"As stated in its official documentation section, it should only be used by\ncss-in-js library authors, if not, please use ",(0,o.kt)("inlineCode",{parentName:"p"},"useLayoutEffect")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect"),"."),(0,o.kt)("h3",{id:"signature-6"},"Signature"),(0,o.kt)("p",null,"Same as other effects, the ",(0,o.kt)("inlineCode",{parentName:"p"},"useInsertionEffect")," is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  // [Not Native Code]\n}\n")),(0,o.kt)("h3",{id:"implementation-4"},"Implementation"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useInsertionEffect")," implementation is the ",(0,o.kt)("a",{parentName:"p",href:"#how-useeffect-works"},"same as ",(0,o.kt)("inlineCode",{parentName:"a"},"useEffect")),",\nthe only difference is the ",(0,o.kt)("inlineCode",{parentName:"p"},"flags")," being passed on mount to ",(0,o.kt)("inlineCode",{parentName:"p"},"mountEffectImpl"),"\nand on update to ",(0,o.kt)("inlineCode",{parentName:"p"},"updateEffectImpl"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"On mount: React passes ",(0,o.kt)("inlineCode",{parentName:"li"},"UpdateEffect")," as fiber flags and ",(0,o.kt)("inlineCode",{parentName:"li"},"HookInsertion")," as\nhook flags."),(0,o.kt)("li",{parentName:"ul"},"On update: React passes ",(0,o.kt)("inlineCode",{parentName:"li"},"UpdateEffect")," as fiber flags and ",(0,o.kt)("inlineCode",{parentName:"li"},"HookInsertion")," as\nhook flags.")),(0,o.kt)("p",null,"And that's it! All effects only differ in the flags."),(0,o.kt)("h2",{id:"how-uselayouteffect-works"},"How useLayoutEffect works"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useLayoutEffect"},(0,o.kt)("inlineCode",{parentName:"a"},"useLayoutEffect")," hook"),"\nby definition is:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Is a version of useEffect that fires before the browser repaints the screen.")),(0,o.kt)("p",null,"Well, that's not totally true when it comes to comparing it to useEffect,\nthe ",(0,o.kt)("a",{parentName:"p",href:"/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works"},(0,o.kt)("inlineCode",{parentName:"a"},"how commit works")," section"),"\nwill reveal more information about that."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useLayoutEffect")," allows you to register effect that run after the render phase\nsynchronously after mutating the dom elements."),(0,o.kt)("p",null,"Its synchronous nature blocks the browser's main thread and thus prevent it from\npartially painting the new render resulting UI. Which makes us often say:\n",(0,o.kt)("inlineCode",{parentName:"p"},"useLayoutEffect")," runs before the browser's paint."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useLayoutEffect")," runs at the same time as ",(0,o.kt)("inlineCode",{parentName:"p"},"ClassComponent")," lifecycle methods\n(",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidUpdate"),")"),(0,o.kt)("h3",{id:"signature-7"},"Signature"),(0,o.kt)("p",null,"Same as other effects, the ",(0,o.kt)("inlineCode",{parentName:"p"},"useInsertionEffect")," is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  // [Not Native Code]\n}\n")),(0,o.kt)("h3",{id:"implementation-5"},"Implementation"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useLayoutEffect")," implementation is the ",(0,o.kt)("a",{parentName:"p",href:"#how-useeffect-works"},"same as ",(0,o.kt)("inlineCode",{parentName:"a"},"useEffect")),",\nthe only difference is the ",(0,o.kt)("inlineCode",{parentName:"p"},"flags")," being passed on mount to ",(0,o.kt)("inlineCode",{parentName:"p"},"mountEffectImpl"),"\nand on update to ",(0,o.kt)("inlineCode",{parentName:"p"},"updateEffectImpl"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"On mount: React passes ",(0,o.kt)("inlineCode",{parentName:"li"},"UpdateEffect | LayoutStaticEffect")," as fiber flags and\n",(0,o.kt)("inlineCode",{parentName:"li"},"HookLayout")," as hook flags."),(0,o.kt)("li",{parentName:"ul"},"On update: React passes ",(0,o.kt)("inlineCode",{parentName:"li"},"UpdateEffect")," as fiber flags and ",(0,o.kt)("inlineCode",{parentName:"li"},"HookLayout")," as\nhook flags.")),(0,o.kt)("p",null,"And that's it! All effects only differ in the flags."),(0,o.kt)("h2",{id:"how-usememo-works"},"How useMemo works"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useMemo"},(0,o.kt)("inlineCode",{parentName:"a"},"useMemo")," hook")," allows you to\ncache a value until a dependency changes."),(0,o.kt)("h3",{id:"signature-8"},"Signature"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"Where:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"nextCreate")),": The function that will output our cached value"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"deps")),": The dependencies")),(0,o.kt)("h3",{id:"implementation-on-mount-2"},"Implementation on mount"),(0,o.kt)("p",null,"On mount, ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," will ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2623"},"call ",(0,o.kt)("inlineCode",{parentName:"a"},"mountMemo")),"\nwhich is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  // step 1\n  // highlight-next-line\n  const hook = mountWorkInProgressHook();\n  // step 2\n  // highlight-next-line\n  const nextDeps = deps === undefined ? null : deps;\n  // step 3\n  // highlight-next-line\n  const nextValue = nextCreate();\n  // step 4\n  // highlight-next-line\n  hook.memoizedState = [nextValue, nextDeps];\n  // step 5\n  // highlight-next-line\n  return nextValue;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": create the hook object on mount"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": calculate the deps to use, either the provided ones or ",(0,o.kt)("inlineCode",{parentName:"li"},"null")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": calculate the initial memo value"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": store ",(0,o.kt)("inlineCode",{parentName:"li"},"[nextvalue, nextDeps]")," as the ",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," of the hook"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 5"),": return the cached value")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"When in development mode and under StrictMode, React will call the ",(0,o.kt)("inlineCode",{parentName:"p"},"nextCreate"),"\ntwice:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// initialized in the renderWithHooks function\nif (shouldDoubleInvokeUserFnsInHooksDEV) {\n  nextCreate();\n}\n"))),(0,o.kt)("h3",{id:"implementation-on-update-2"},"Implementation on update"),(0,o.kt)("p",null,"On updates, ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," will ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2637"},"call ",(0,o.kt)("inlineCode",{parentName:"a"},"updateMemo")),"\nwhich is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  // step 1\n  // highlight-next-line\n  const hook = updateWorkInProgressHook();\n  // step 2\n  // highlight-next-line\n  const nextDeps = deps === undefined ? null : deps;\n  // step 3\n  // highlight-next-line\n  const prevState = hook.memoizedState;\n  // Assume these are defined. If they're not, areHookInputsEqual will warn.\n  if (nextDeps !== null) {\n    const prevDeps: Array<mixed> | null = prevState[1];\n    // step 4\n    // highlight-next-line\n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      return prevState[0];\n    }\n  }\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    nextCreate();\n  }\n  // step 5\n  // highlight-next-line\n  const nextValue = nextCreate();\n  // step 6\n  // highlight-next-line\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": create the hook object on update (or reuse from incomplete render)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": calculate the deps to use, either the provided ones or ",(0,o.kt)("inlineCode",{parentName:"li"},"null")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": reference the previous rendered value (even if the render was\nincomplete, use the rendered value, because it matters)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": when dependencies are the same, the previously cached value is\nreturned"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 5"),": compute again the cached value using the passed ",(0,o.kt)("inlineCode",{parentName:"li"},"nextCreate")," memo\nfunction"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 6"),": store the ",(0,o.kt)("inlineCode",{parentName:"li"},"[nextValue, nextDeps]")," along with the deps in the\n",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," of the hook and return the new cached value.")),(0,o.kt)("p",null,"And that's it! ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," is similar to ",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback")," in terms of implementation\nand complexity, the difference is that ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," calls your function and\n",(0,o.kt)("inlineCode",{parentName:"p"},"useCallback")," will give it back to you."),(0,o.kt)("h2",{id:"how-usereducer-works"},"How useReducer works"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useReducer"},(0,o.kt)("inlineCode",{parentName:"a"},"useReducer")," hook")," allows\nyou to add a reducer to your component."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"reducer")," is a function that accepts two arguments: the current ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," and\nan ",(0,o.kt)("inlineCode",{parentName:"p"},"action")," to apply on that value, then return a ",(0,o.kt)("inlineCode",{parentName:"p"},"new value"),". Like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function reducer(prevValue, action) {\n  // perform some logic based on the action and the value\n  // ...\n  // then return a new value\n}\n")),(0,o.kt)("h3",{id:"signature-9"},"Signature"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," hook is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useReducer<S, I, A>(\n  reducer: (state: S, action: A) => S,\n  initialArg: I,\n  init?: (initialValue: I) => S,\n): [S, Dispatch<A>] {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"Where the arguments are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"reducer"),": The reducer function"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"initialArg"),": The initial value"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"init"),": An optional initializer function that receives the ",(0,o.kt)("inlineCode",{parentName:"li"},"initialArg"))),(0,o.kt)("p",null,"And it returns an array containing two elements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"state"),": the state value"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"dispatch"),": a function that accepts the ",(0,o.kt)("inlineCode",{parentName:"li"},"action")," to pass to our reducer.")),(0,o.kt)("h3",{id:"implementation-on-mount-3"},"Implementation on mount"),(0,o.kt)("p",null,"When a component using ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," mounts for the first time, the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1177"},(0,o.kt)("inlineCode",{parentName:"a"},"mountReducer")," function"),"\ngets called. Let's break into it:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Mount the work in progress hook:"),(0,o.kt)("p",{parentName:"li"},"As you would expect, the first thing to do is this one. If you don't\nunderstand why, you probably did skip this whole section \ud83d\ude11"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const hook = mountWorkInProgressHook();\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Compute the initial state:\nThe initial state computation depends on whether you provided the third\nparameter:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"let initialState;\nif (init !== undefined) {\n  initialState = init(initialArg);\n} else {\n  initialState = (initialArg as S);\n}\n")),(0,o.kt)("p",{parentName:"li"},"It is either the ",(0,o.kt)("inlineCode",{parentName:"p"},"initialArg")," or the result of your function about it.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Assign the hook ",(0,o.kt)("inlineCode",{parentName:"p"},"memoizedState")," property"),(0,o.kt)("p",{parentName:"li"},"This unveils what this hook stores in the ",(0,o.kt)("inlineCode",{parentName:"p"},"memoizedState")," property. But not\nit also populates the ",(0,o.kt)("inlineCode",{parentName:"p"},"baseState")," property at this stage."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"hook.memoizedState = hook.baseState = initialState;\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create an UpdateQueue object and assign it"),(0,o.kt)("p",{parentName:"li"},"The update queue is an object referring to the internal state of ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer"),",\nwe won't deal with it here, but mostly when the component is updating or when\nReact is scheduling/processing state updates. But it is important to take a\nlook at its shape and referenced things."),(0,o.kt)("p",{parentName:"li"},"At first, it only references the initially given ",(0,o.kt)("inlineCode",{parentName:"p"},"reducer")," and the computed\n",(0,o.kt)("inlineCode",{parentName:"p"},"initialState")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const queue: UpdateQueue<S, A> = {\n  pending: null,\n  lanes: NoLanes,\n  dispatch: null,\n  lastRenderedReducer: reducer,\n  lastRenderedState: initialState,\n};\nhook.queue = queue;\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create the dispatch function and return"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const dispatch: Dispatch<A> = (queue.dispatch = dispatchReducerAction.bind(\n  null,\n  currentlyRenderingFiber,\n  queue,\n));\nreturn [hook.memoizedState, dispatch];\n")),(0,o.kt)("p",{parentName:"li"},"The dispatch function is very important and is defined elsewhere, ",(0,o.kt)("inlineCode",{parentName:"p"},"mountReducer"),"\nwill just give it two of the three parameters it accepts. Let's break it."))),(0,o.kt)("h3",{id:"how-dispatchreduceraction-works"},"How ",(0,o.kt)("inlineCode",{parentName:"h3"},"dispatchReducerAction")," works"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"dispatchReducerAction")," is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function dispatchReducerAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n): void {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"Its job is to tell React to schedule an update on the desired ",(0,o.kt)("inlineCode",{parentName:"p"},"fiber")," and its\n",(0,o.kt)("inlineCode",{parentName:"p"},"queue")," (a component can have several ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer"),"s, the queue holds all the\npending updates to be processed), using the given ",(0,o.kt)("inlineCode",{parentName:"p"},"action"),"."),(0,o.kt)("p",null,"In other terms, this is the ",(0,o.kt)("inlineCode",{parentName:"p"},"dispatch")," function ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," give\nyou."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"So, now, you are reading how the stateSetter works for function components.")),(0,o.kt)("p",null,"The rest of this part would be easier if you've already read\n",(0,o.kt)("a",{parentName:"p",href:"/how-react-works/docs/react-dom/how.root_render.works#2-request-an-update-lane"},"the ",(0,o.kt)("inlineCode",{parentName:"a"},"how root.render() works")," section.")),(0,o.kt)("p",null,"We won't explain again many things to keep this part easy. Scheduling updates\nworks almost the same."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Request an update lane"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const lane = requestUpdateLane(fiber);\n")),(0,o.kt)("p",{parentName:"li"},"The very first step is to infer the ",(0,o.kt)("inlineCode",{parentName:"p"},"lane")," for this upcoming update, for\nexample:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If your application wasn't rendered through concurrent mode\n(",(0,o.kt)("inlineCode",{parentName:"li"},"createRoot().render()"),") then the ",(0,o.kt)("inlineCode",{parentName:"li"},"SyncLane")," is used."),(0,o.kt)("li",{parentName:"ul"},"If a render phase update, then the highest priority lane is used\n(or, the smallest Lane present in the given Lanes number \ud83d\ude09)."),(0,o.kt)("li",{parentName:"ul"},"One of the transition lanes if wrapped in ",(0,o.kt)("inlineCode",{parentName:"li"},"startTransition")),(0,o.kt)("li",{parentName:"ul"},"An event priority as seen in ",(0,o.kt)("a",{parentName:"li",href:"/how-react-works/docs/react-dom/how.root_render_schedule.works#implementation-steps"},"how root render schedule works")))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create an update object"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const update: Update<S, A> = {\n  lane,\n  revertLane: NoLane,\n  action,\n  hasEagerState: false,\n  eagerState: null,\n  next: null,\n};\n")),(0,o.kt)("p",{parentName:"li"},"The update is defined by many properties, but the only two relevant for now\nare the update ",(0,o.kt)("inlineCode",{parentName:"p"},"lane")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"action"),". React keeps track of them in order to\nbe able to play them later.\nOf course, one other important property is ",(0,o.kt)("inlineCode",{parentName:"p"},"next"),".. A linked list again.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Enqueue a render phase update when called during render"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (isRenderPhaseUpdate(fiber)) {\n  enqueueRenderPhaseUpdate(queue, update);\n}\n")),(0,o.kt)("p",{parentName:"li"},"A render phase update is detected when the ",(0,o.kt)("inlineCode",{parentName:"p"},"fiber")," is equal to\n",(0,o.kt)("inlineCode",{parentName:"p"},"currentlyRenderingFiber")," or its alternate."),(0,o.kt)("p",{parentName:"li"},"When it is the case, React will call the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3347"},(0,o.kt)("inlineCode",{parentName:"a"},"enqueueRenderPhaseUpdate")," function"),"\nwhich is implemented as follows:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"\nfunction enqueueRenderPhaseUpdate<S, A>(\n  queue: UpdateQueue<S, A>,\n  update: Update<S, A>,\n): void {\n  // step 1\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  const pending = queue.pending;\n  if (pending === null) {\n    // step 2\n    update.next = update;\n  } else {\n    // step 3\n    update.next = pending.next;\n    pending.next = update;\n  }\n  // step 4\n  queue.pending = update;\n}\n")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": Mark as did schedule a render phase update. This variable\nis important for React since it will allow it to render the component\nagain before going to other components or committing."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": When there is no pending updates in the queue, the update\nwill point to itself as ",(0,o.kt)("inlineCode",{parentName:"li"},"next")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": When there are some pending updates, since it is a circular\nlinked list (meaning that the ",(0,o.kt)("inlineCode",{parentName:"li"},"pending")," is the last item, and ",(0,o.kt)("inlineCode",{parentName:"li"},"pending.next"),"\nis the first), then we will perform a small gymnastic to mark the first\nupdate as the next of the new update, and the new update the next of the\nfirst."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": Lately, React will mark the new ",(0,o.kt)("inlineCode",{parentName:"li"},"update")," as the ",(0,o.kt)("inlineCode",{parentName:"li"},"pending"),"\nof the queue (it is the last update to be performed.)"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"When not called during render, enqueue a concurrent hook update, then\nschedule an update on the fiber, then entangle transitions"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (false) {} else {\n  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, fiber, lane);\n    entangleTransitionUpdate(root, queue, lane);\n  }\n}\n")),(0,o.kt)("p",{parentName:"li"},"I won't explain this again to keep this section brief, all of this was\nexplained ",(0,o.kt)("a",{parentName:"p",href:"/how-react-works/docs/react-dom/how.root_render.works#5-enqueue-the-created-update-to-the-fiber"},"during ",(0,o.kt)("inlineCode",{parentName:"a"},"how root.render() works"),"!"),".\nIt works the same!"),(0,o.kt)("p",{parentName:"li"},"At the end we will have a microtask scheduled to process the updateQueue\nof the fiber that caused the render."))),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Scheduling updates an efficient process, combined with the fast that react\ncombine fiber ",(0,o.kt)("inlineCode",{parentName:"p"},"flags")," of children into their parents, it knows for sure\nwhen to start the work and when to stop."),(0,o.kt)("p",{parentName:"admonition"},"The important things to note:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"React doesn't process the updates on the fly, but add them to the queue and\nschedules the work for later."),(0,o.kt)("li",{parentName:"ul"},"React keeps track of the update details (the queue, the action/value/updater)\nso it can process them later."),(0,o.kt)("li",{parentName:"ul"},"Queuing updates allows React to batch them and render one time rather than many."))),(0,o.kt)("h3",{id:"implementation-on-update-3"},"Implementation on update"),(0,o.kt)(i.Z,{mdxType:"TBD"}),(0,o.kt)("h2",{id:"how-useref-works"},"How useRef works"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"[useRef")," hook](",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useRef"},"https://react.dev/reference/react/useRef"),") gives you a\nreference that you can control as you please. You can reference any javascript\nvalue in it."),(0,o.kt)("p",null,"In the official docs, it is stated that:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"useRef is a React Hook that lets you reference a value that\u2019s not needed for\nrendering.")),(0,o.kt)("p",null,"React tries to push you not to use this ref and base your decisions on it while\nthe component is rendering. It is okay though to manipulate it outside render."),(0,o.kt)("p",null,"For example, if you mutate this value during render, React may render several\ntimes and thus write on it multiple times. The easiest way to observe this for\nexample is by using a ref to count how many times your component rendered. In\ndevelopment mode and under strict mode, you will all the time get wrong results.\nThat one reason to get away from it for this kind of usage."),(0,o.kt)("p",null,"People also often use the ref to detect whether the component is currently\nmounting or not, but this is also wrong: since if the component mounted already\nthen suspended waiting for data while showing a Suspense fallback, the component\nstays mounted and thus any decision based on that value will be wrong."),(0,o.kt)("p",null,"You can also pass this ref object to any HTML element and React will attach the\nreal DOM element on layout effect. Again, this is yet another reason to get\naway from this hook during render and minimize its usage."),(0,o.kt)("p",null,"Please refer to the official docs to learn more when to use and when not\nto use the ",(0,o.kt)("inlineCode",{parentName:"p"},"useRef")," hook."),(0,o.kt)("h3",{id:"signature-10"},"Signature"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useRef")," hook is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountRef<T>(initialValue: T): {current: T} {\n  // [Not Native Code]\n}\n")),(0,o.kt)("h3",{id:"implementation-on-mount-4"},"Implementation on mount"),(0,o.kt)("p",null,"When your component using ",(0,o.kt)("inlineCode",{parentName:"p"},"useRef")," renders for the first time, it will call\nthe ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2257"},(0,o.kt)("inlineCode",{parentName:"a"},"mountRef")," function"),",\nwhich is probably the easiest hook ever:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified: dev warning about reading from ref during render were removed\n// for clarity\nfunction mountRef<T>(initialValue: T): {current: T} {\n  // step 1\n  // highlight-next-line\n  const hook = mountWorkInProgressHook();\n  // step 2\n  // highlight-next-line\n  const ref = {current: initialValue};\n  // step 3\n  // highlight-next-line\n  hook.memoizedState = ref;\n  // step 4\n  // highlight-next-line\n  return ref;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": create the hook object on mount"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": create a javascript object with one ",(0,o.kt)("inlineCode",{parentName:"li"},"current")," property,\ninitialized by the ",(0,o.kt)("inlineCode",{parentName:"li"},"initialValue")," received by ",(0,o.kt)("inlineCode",{parentName:"li"},"useRef")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": store this object as the ",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," of this hook"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": return the ref object")),(0,o.kt)("h3",{id:"implementation-on-update-4"},"Implementation on update"),(0,o.kt)("p",null,"On updates, ",(0,o.kt)("inlineCode",{parentName:"p"},"useRef")," will call the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2326"},(0,o.kt)("inlineCode",{parentName:"a"},"updateRef")," function"),"\nwhich is very simple and doesn't need any explanations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function updateRef<T>(initialValue: T): {current: T} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n")),(0,o.kt)("p",null,"It just creates the hook object while reusing the ref mutable object as is,\nand will return the memoized state directly."),(0,o.kt)("h2",{id:"how-usestate-works"},"How useState works"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useState"},(0,o.kt)("inlineCode",{parentName:"a"},"useState")," hook")," allows you to\nadd a variable to your component that it will cause it to update when its value\nchanges."),(0,o.kt)("p",null,"From the Official documentation:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"useState is a React Hook that lets you add a state variable to your component.")),(0,o.kt)("p",null,"State is the only reactive primitive in React for now (promises somehow are\nreactive, but under the hood, they call ",(0,o.kt)("inlineCode",{parentName:"p"},"scheduleUpdateOnFiber")," too, and\nit's kind hard to work only with them.)."),(0,o.kt)("p",null,"The rest of this section assumes that you've read the ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," section."),(0,o.kt)("h3",{id:"signature-11"},"Signature"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useState")," is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  // [Not Native Code]\n}\n")),(0,o.kt)("p",null,"It accepts one single parameter called the ",(0,o.kt)("inlineCode",{parentName:"p"},"initialState")," which is the initial\nstate value of a function that will produce it."),(0,o.kt)("h3",{id:"implementation-on-mount-5"},"Implementation on mount"),(0,o.kt)("p",null,"Well, we'll have to spoil this already: ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," where the\nreducer is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n")),(0,o.kt)("p",null,"So, if you give ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," this reducer which, if it receives a function, it\nwill call it with the actual state, or else just take the passed value.\n",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," will behave like ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," as we know it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  // step 1\n  // highlight-next-line\n  const hook = mountStateImpl(initialState);\n  const queue = hook.queue;\n  // step 2\n  // highlight-next-line\n  const dispatch: Dispatch<BasicStateAction<S>> = dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  );\n  // step 3\n  // highlight-next-line\n  queue.dispatch = dispatch;\n  return [hook.memoizedState, dispatch];\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": The first step is where we will call ",(0,o.kt)("inlineCode",{parentName:"li"},"mountWIPHook")," and initialize\nthe hook object and ",(0,o.kt)("inlineCode",{parentName:"li"},"UpdateQueue"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": Reference the queue to use it while creating the ",(0,o.kt)("inlineCode",{parentName:"li"},"dispatch"),"\nfunction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": Return the ",(0,o.kt)("inlineCode",{parentName:"li"},"useState")," value which is a tuple of the state current\nvalue and the dispatch function (",(0,o.kt)("inlineCode",{parentName:"li"},"setState"),").")),(0,o.kt)("h4",{id:"how-mountstateimpl-works"},"How ",(0,o.kt)("inlineCode",{parentName:"h4"},"mountStateImpl")," works"),(0,o.kt)("p",null,"Let's take a look at how this function is implemented:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountStateImpl<S>(initialState: (() => S) | S): Hook {\n  // step 1\n  // highlight-next-line\n  const hook = mountWorkInProgressHook();\n  // step 2\n  // highlight-next-line\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n  // step 3\n  // highlight-next-line\n  hook.memoizedState = hook.baseState = initialState;\n  // step 4\n  // highlight-next-line\n  const queue: UpdateQueue<S, BasicStateAction<S>> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  return hook;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 1"),": Mount the hook object inside the linked list of hooks."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 2"),": Call the initializer function if ",(0,o.kt)("inlineCode",{parentName:"li"},"initialState")," is a function."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 3"),": Mark the hook's ",(0,o.kt)("inlineCode",{parentName:"li"},"memoizedState")," as the initial value. Same for\n",(0,o.kt)("inlineCode",{parentName:"li"},"baseState"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Step 4"),": Create the update queue object and assign it to the hook's queue.")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"And that's it! useState is useReducer. Take a look at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/commit/7bee9fbdd49aa5b9365a94b0ddf6db04bc1bf51c"},"the commit where hooks"),"\nwere introduced back to 2018. It was literally:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export function useState<S>(\n  initialState: S | (() => S),\n): [S, Dispatch<S, BasicStateAction<S>>] {\n  return useReducer(basicStateReducer, initialState);\n}\n"))),(0,o.kt)("h3",{id:"implementation-on-update-5"},"Implementation on update"),(0,o.kt)("p",null,"On updates, ",(0,o.kt)("inlineCode",{parentName:"p"},"updateState")," will delegate the work entirely to ",(0,o.kt)("inlineCode",{parentName:"p"},"updateReducer"),",\nand that's it!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, initialState);\n}\n")),(0,o.kt)("h2",{id:"how-usedebugvalue-works"},"How useDebugValue works"),(0,o.kt)("p",null,"This is an empty hook that only works in development mode."),(0,o.kt)("p",null,"The implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"useDebugValue")," is empty as ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2594"},"shown in ",(0,o.kt)("inlineCode",{parentName:"a"},"mountDebugValue"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountDebugValue<T>(value: T, formatterFn?: (value: T) => mixed): void {\n  // This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n")),(0,o.kt)("p",null,"When taking a look at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/aec521a96d3f1bebc2ba38553d14f4989c6e88e0/packages/react-debug-tools/src/ReactDebugHooks.js#L238"},"the ",(0,o.kt)("inlineCode",{parentName:"a"},"ReactDebugHooks.js")," file"),"\nwe can see that this hook's implementation only pushes the logged value\nto a module level array that collects information to be shown in the React\ndevtools, which is out of scope of this article and won't be an easy thing\nto document for now."),(0,o.kt)("h2",{id:"how-usedeferredvalue-works"},"How useDeferredValue works"),(0,o.kt)(i.Z,{mdxType:"TBD"}),(0,o.kt)("h2",{id:"how-usetransition-works"},"How useTransition works"),(0,o.kt)(i.Z,{mdxType:"TBD"}),(0,o.kt)("h2",{id:"how-usesyncexternalstore-works"},"How useSyncExternalStore works"),(0,o.kt)(i.Z,{mdxType:"TBD"}),(0,o.kt)("h2",{id:"how-useid-works"},"How useId works"),(0,o.kt)(i.Z,{mdxType:"TBD"}),(0,o.kt)("h2",{id:"annex"},"Annex"),(0,o.kt)("p",null,"This is a table for all the internal stored value for all hooks:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Hook"),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"th"},"memoizedState")),(0,o.kt)("th",{parentName:"tr",align:null},"Comment(s)"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"use")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"N/A")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"use")," doesn't obey the rules of hooks and does not use the internal data structure")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useCallback")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"[callback, deps]")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useCallback")," saves the passed callback and dependencies")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useContext")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"N/A")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useContext")," doesn't rely on hooks call order, it is stored in the ",(0,o.kt)("inlineCode",{parentName:"td"},"fiber.dependencies")," property")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useEffect")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"effect")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useEffect")," saves the effect object created by ",(0,o.kt)("inlineCode",{parentName:"td"},"pushEffect")," which references the effect function, the deps and so on")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useImperativeHandle")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"effect")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useImperativeHandle")," calls is a ",(0,o.kt)("inlineCode",{parentName:"td"},"useLayoutEffect")," under the hood")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useLayoutEffect")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"effect")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useLayoutEffect")," saves the effect object created by ",(0,o.kt)("inlineCode",{parentName:"td"},"pushEffect")," which references the effect function, the deps and so on")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useInsertionEffect")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"effect")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useInsertionEffect")," saves the effect object created by ",(0,o.kt)("inlineCode",{parentName:"td"},"pushEffect")," which references the effect function, the deps and so on")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useMemo")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"[value, deps]")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useMemo")," saves the resulting cached value and the dependencies")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useReducer")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"state")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useReducer")," saves only the state value in memoizedState, dispatch is stored in the queue")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useRef")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"{current: value}")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useRef")," saves the ",(0,o.kt)("inlineCode",{parentName:"td"},"{current: value}")," as memoized state")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useState")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"state")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useState")," is ",(0,o.kt)("inlineCode",{parentName:"td"},"useReducer")," with a special reducer, it saves only the state value in memoizedState, dispatch is stored in the queue")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useDebugValue")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"N/A")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useDebugValue")," is an empty hook that is inject by the devtools")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useDeferredValue")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"TBD")),(0,o.kt)("td",{parentName:"tr",align:null})),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useTransition")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"TBD")),(0,o.kt)("td",{parentName:"tr",align:null})),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useSyncExternalStore")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"TBD")),(0,o.kt)("td",{parentName:"tr",align:null})),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"useId")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"TBD")),(0,o.kt)("td",{parentName:"tr",align:null})))))}h.isMDXComponent=!0},4675:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/10.fiber_and_hook-e0e8b8ce545dbc127cc01d093c7dd427.png"}}]);