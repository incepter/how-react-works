---
sidebar_position: 4
---

# How the work loop works

In the `how root.render(children) works` section, the last thing we did is to
schedule via microtask our application's render ( via
`scheduleImmediateTask(processRootScheduleInMicrotask)`).
Or to be more precise, we have a scheduled root with `pending` work stored in 
the global `firstScheduledRoot` variable. 

The work-loop is the process of rendering your components and displaying them
on the screen. The work is triggerred by several actions: `root.render()`,
components updates, recovering from suspense... etc.

Since we are coming from `root.render(children)`, we will first explain how we
would reach the work loop, and then dive into it.

## How `processRootScheduleInMicrotask` works

When the callstack becomes empty, the javascript event-loop will process the
task queue, and will eventually call the callback [scheduled here.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L120)

If you are wondering, how can they be multiple roots?
It is because React can run in the server too and render for several requests
in parallel. React's code smartly and dangerously plays with globals in order
to unlock many of the concurrent features.

[processRootScheduleInMicrotask](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L233)
will loop over the scheduled roots (in our simple case, the render of a small
application via `root.render()`, there will only one root). And for each root:

```tsx

let root = firstScheduledRoot;
while (root !== null) {
  // perform logic for current root
  
  root = next;
}

```

1. Entangle the root to a `SyncLane` if we are inside a [`popstate` event](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L253).
2. Call `scheduleTaskForRootDuringMicrotask` to get the `nextLanes` for this `root`.
   This function is very important and that's when the work-loop will be
   triggered, we will see it right after.
3. If there is no pending work (`nextLanes === NoLane`), then the root is removed
   from the chain: Remember? We may have multiple roots in a linked list way,
   when there is no pending work to do on a root, it is detached from that list.
4. If there is still work to do, keep this root in the list and verify if it
   contains a sync work.
5. Flush sync work


In summary, here is a simplified version of what happened:

```tsx
// simplified, a lot

const currentTime = Date.now();
let root = firstScheduledRoot;

while (root !== null) {
  const next = root.next;
  // 1
  entangleSyncLaneIfInsidePopStateEvent(root);
  // 2
  const nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
  // 3
  if (nextLanes === NoLane) { // no pending work to do
    detachRootFromScheduledRoots(root);
  } else {
    // 4
    if (includesSyncLane(nextLanes)) {
      mightHavePendingSyncWork = true;
    }
  }
  root = next;
}

// 5
flushSyncWorkOnAllRoots();
```

## How `scheduleTaskForRootDuringMicrotask` works

The second step above did make a call to [this function](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L294)
which is defined as follows:

### Signature

```tsx
function scheduleTaskForRootDuringMicrotask(
  root: FiberRoot,
  currentTime: number,
): Lane { /* [Not Native Code] */ }
```

This function returns the highest priority lane that's scheduled.

### Implementation steps

1. Mark starved lanes as expired
   
   In this process, we will go through the root's `pendingLanes` one by one
   and either compute an expiration time for it if not already computed,
   or else, check if it expired and add it to `root.expiredLanes`:
   ```tsx
   // simplified
   let lanes = pendingLanes & ~RetryLanes;
   while (lanes > 0) {
     // in the following two lines, we will get the index of the highest priority
     // lane from the lanes, and then we will shift 1 by that index so we obtain
     // the current lane with only one significant bit (power of 2)
     const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
   
     const expirationTime = root.expirationTimes[index];
     
     if (expirationTime !== NoTimestamp) {
       if (
         (lane & suspendedLanes) === NoLanes ||
         (lane & pingedLanes) !== NoLanes
       ) {
         expirationTimes[index] = computeExpirationTime(lane, currentTime);
       }
     } else if (expirationTime <= currentTime) {
       root.expiredLanes |= lane;
     }
   
     lanes &=  ~lane;
   }
   ```
   Check the codebase via [this link.](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L384)

2. Compute the next lanes
   
   Next, React will [compute the next lanes:](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L315)

   ```tsx 
   // When coming from root.render(children)
   const nextLanes = getNextLanes(root, NoLanes);
   ```
3. Exit when there is no pending work or suspended on data
   
   When `nextLanes` are equal to `NoLanes` (which means there is no `pending`
   work to do), or the root is suspended on data, or the root has a scheduled
   pending commit callback (we will see it later) then it will:
   - Cancel the existing callback if any
   - Clean the `root.callbackNode` and `root.callbackPriority` properties
   - return `NoLane`
   
   Read more here on [the real implementation.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L321)
   
4. Exit when there is a Sync pending work
   
   Sync work will be flushed by `processRootScheduleInMicrotask` and will be
   detailed in the next section.
   
5. Schedule the render on the current root
   
   By here, we have a pending concurrent work to do, then we will compute a
   priority from the `nextLanes`:
   

:::note
After looping over all scheduled roots and re-schedule their render,
`processRootScheduleInMicrotask` will finally [flush sync work on all roots.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L291)
:::

## How flush sync work on roots works

## How the concurrent work loop works

