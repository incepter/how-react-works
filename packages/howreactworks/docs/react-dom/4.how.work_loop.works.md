---
sidebar_position: 4
---

# How the work loop works

In `how root.render() works` section, the last thing we did is to
schedule via microtask our application's render ( via
`scheduleImmediateTask(processRootScheduleInMicrotask)`).
Or to be more precise, we have a scheduled root with `pending` work stored in 
the global `firstScheduledRoot` variable. 

The work-loop is the process of rendering your components and displaying them
on the screen. The work is triggerred by several actions: `root.render()`,
components updates, recovering from suspense... etc.

Since we are coming from `root.render()`, we will first explain how we
would reach the work loop, and then dive into it.

## How `processRootScheduleInMicrotask` works

When the callstack becomes empty, the javascript event-loop will process the
task queue, and will eventually call the callback [scheduled here.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L120)

If you are wondering, how can they be multiple roots?
It is because React can run in the server too and render for several requests
in parallel. React's code smartly and dangerously plays with globals in order
to unlock many of the concurrent features.

[processRootScheduleInMicrotask](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L233)
will loop over the scheduled roots (in our simple case, the render of a small
application via `root.render()`, there will only one root). And for each root:

```tsx

let root = firstScheduledRoot;
while (root !== null) {
  // perform logic for current root
  
  root = next;
}

```

1. Entangle the root to a `SyncLane` if we are inside a [`popstate` event](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L253).
2. Call `scheduleTaskForRootDuringMicrotask` to get the `nextLanes` for this `root`.
   This function is very important and that's when the work-loop will be
   triggered, we will see it right after.
3. If there is no pending work (`nextLanes === NoLane`), then the root is removed
   from the chain: Remember? We may have multiple roots in a linked list way,
   when there is no pending work to do on a root, it is detached from that list.
4. If there is still work to do, keep this root in the list and verify if it
   contains a sync work.
5. Flush sync work


In summary, here is a simplified version of what happened:

```tsx
// simplified, a lot

const currentTime = Date.now();
let root = firstScheduledRoot;

while (root !== null) {
  const next = root.next;
  // 1
  entangleSyncLaneIfInsidePopStateEvent(root);
  // 2
  const nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
  // 3
  if (nextLanes === NoLane) { // no pending work to do
    detachRootFromScheduledRoots(root);
  } else {
    // 4
    if (includesSyncLane(nextLanes)) {
      mightHavePendingSyncWork = true;
    }
  }
  root = next;
}

// 5
flushSyncWorkOnAllRoots();
```

## How `scheduleTaskForRootDuringMicrotask` works

The second step above did make a call to [this function](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L294)
which is defined as follows:

### Signature

```tsx
function scheduleTaskForRootDuringMicrotask(
  root: FiberRoot,
  currentTime: number,
): Lane { /* [Not Native Code] */ }
```

This function returns the highest priority lane that's scheduled.

### Implementation steps

1. Mark starved lanes as expired
   
   In this process, we will go through the root's `pendingLanes` one by one
   and either compute an expiration time for it if not already computed,
   or else, check if it expired and add it to `root.expiredLanes`:
   ```tsx
   // simplified
   let lanes = pendingLanes & ~RetryLanes;
   while (lanes > 0) {
     // in the following two lines, we will get the index of the highest priority
     // lane from the lanes, and then we will shift 1 by that index so we obtain
     // the current lane with only one significant bit (power of 2)
     const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
   
     const expirationTime = root.expirationTimes[index];
     
     if (expirationTime !== NoTimestamp) {
       if (
         (lane & suspendedLanes) === NoLanes ||
         (lane & pingedLanes) !== NoLanes
       ) {
         expirationTimes[index] = computeExpirationTime(lane, currentTime);
       }
     } else if (expirationTime <= currentTime) {
       root.expiredLanes |= lane;
     }
   
     lanes &=  ~lane;
   }
   ```
   Check the codebase via [this link.](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L384)

2. Compute the next lanes
   
   Next, React will [compute the next lanes:](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L315)

   ```tsx 
   // When coming from root.render(children)
   const nextLanes = getNextLanes(root, NoLanes);
   ```
3. Exit when there is no pending work or suspended on data
   
   When `nextLanes` are equal to `NoLanes` (which means there is no `pending`
   work to do), or the root is suspended on data, or the root has a scheduled
   pending commit callback (we will see it later) then it will:
   - Cancel the existing callback if any
   - Clean the `root.callbackNode` and `root.callbackPriority` properties
   - return `NoLane`
   
   Read more here on [the real implementation.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L321)
   
4. Exit when there is a Sync pending work
   
   Sync work will be [flushed by `processRootScheduleInMicrotask`](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L344)
   and will be detailed in the next section.
   
   So when a `SyncLane`, we do exactly same as the previous step, and return
   a `SyncLane` rather than `NoLane`.
   
5. Schedule the render on the current root
   
   By here, we have a pending concurrent work to do, then we will compute a
   priority from the `nextLanes`. Wait! what ?
   
   The new `callbackPriority` is implemented now as the `highest priority lane`
   which will be tested against the existing [callback priority](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L358).
   If the priority did not change, React would reuse the same task and priority.
   
   Or else, we would need to infer a `priority` from the `highest priority lane`.
   
   > The highest priority lane is the smallest lane from `nextLanes`.
   
   There are until now [`4` priorities](https://github.com/facebook/react/blob/f101c2d0d3a6cb5a788a3d91faef48462e45f515/packages/react-reconciler/src/ReactEventPriorities.js#L24):
   ```tsx
   export const DiscreteEventPriority: EventPriority = SyncLane;
   export const ContinuousEventPriority: EventPriority = InputContinuousLane;
   export const DefaultEventPriority: EventPriority = DefaultLne;
   export const IdleEventPriority: EventPriority = IdleLane;
   ```

   Hey! Why we are assigning `Lane`s values to them ? Well, priorities are like
   breakpoints for lanes, which means that we can categorize all lanes into
   `4` groups of priorities.
   
   You can look at the [real implementation here:](https://github.com/facebook/react/blob/f101c2d0d3a6cb5a788a3d91faef48462e45f515/packages/react-reconciler/src/ReactEventPriorities.js#L70)

    ```tsx
   // simplified
   const lane = getHighestPriorityLane(nextLanes);
   
   if (DiscreteEventPriority > lane) {
     return DiscreteEventPriority;
   }
   
   if (ContinuousEventPriority > lane) {
     return ContinuousEventPriority;
   }
   
   if (DefaultEventPriority > lane) {
     return DefaultEventPriority;
   }
   
   return IdleEventPriority;
   ```

   Then, we will translate the EventPriority to the [SchedulerPriority:](https://github.com/facebook/react/blob/9cdf8a99edcfd94d7420835ea663edca04237527/packages/scheduler/src/SchedulerPriorities.js#L10)

   ```tsx
   switch (lanesToEventPriority(nextLanes)) {
     case DiscreteEventPriority:
       schedulerPriorityLevel = ImmediateSchedulerPriority;
       break;
     case ContinuousEventPriority:
       schedulerPriorityLevel = UserBlockingSchedulerPriority;
       break;
     case DefaultEventPriority:
       schedulerPriorityLevel = NormalSchedulerPriority;
       break;
     case IdleEventPriority:
       schedulerPriorityLevel = IdleSchedulerPriority;
       break;
     default:
       schedulerPriorityLevel = NormalSchedulerPriority;
       break;
   }
   ```
   
   This part is [implemented here.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L376)
   
   
   At this point, we've reached the very last few things to do:
   [Scheduling the work.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L394)

   ```tsx
   const newCallbackNode = scheduleCallback(
     schedulerPriorityLevel,// NormalPriority for simple root.render
     performConcurrentWorkOnRoot.bind(null, root),
   );
   
   root.callbackPriority = newCallbackPriority;
   root.callbackNode = newCallbackNode;
   return newCallbackPriority;
   ```

   We won't talk about `scheduleCallback` here since it is well documented in
   the `how scheduler works` section. `performConcurrentWorkOnRoot` will be
   detailed in a few.
   

:::note
Reminder: After looping over all scheduled roots and re-schedule their render,
`processRootScheduleInMicrotask` will finally [flush sync work on all roots.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L291)
:::

## How flush sync work on roots works

[This function](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L154)
will loop over all scheduled roots starting from `firstScheduledRoot`, will
exclude any non-legacy roots or those who don't have a `SyncLane` flag.

Then, it will call the [`performSyncWorkOnRoot`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1257)
which will trigger the `sync` work-loop.

We will first start by the `concurrent` work loop then come back to the `sync`
one.

## How the concurrent work loop starts

For the concurrent `root`, the last thing we did is to schedule in
`scheduleTaskForRootDuringMicrotask` a callback to `performConcurrentWorkOnRoot`.

Let's break it.

### `performConcurrentWorkOnRoot` signature

[`performConcurrentWorkOnRoot`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L841)
is defined as follows:

```tsx
export function performConcurrentWorkOnRoot(
  root: FiberRoot,
  didTimeout: boolean,
): RenderTaskFn | null { /* [Not Native Code] */ }
```

The `root` property was bound when scheduling the callback, and the `didTimeout`
will be passed when the scheduler will be calling [this callback.](https://github.com/facebook/react/blob/587ae49d71f218d34393291933d513d2975e22c3/packages/scheduler/src/forks/Scheduler.js#L234)

This function will be rendering your components and performing the whole logic,
so basically it will be insanely long, but we will move some parts from it
to their own sections (like `WorkTags`, `effects` types and implementation
details, and especially`hooks` ).

### Implementation details

1. Guard against calls to this function when already rendering or committing
   ```tsx
   if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
     throw new Error('Should not already be working.');
   }
   ```

2. Flush passive effects

   Effects will be fully discussed in their own section. It will be linked here
   once ready.
   
   ```tsx
   // simplified
   
   // this referencement here because flushPassiveEffects might schedule updates
   const originalCallbackNode = root.callbackNode;
   const didFlushPassiveEffects = flushPassiveEffects();
   
   if (didFlushPassiveEffects && root.callbackNode !== originalCallbackNode) {
     return null;
   }
   ```

   When passive effects are flushed and something did cancel the current
   scheduled callback, this function will stop execution and return `null`.
   
   From the `root.render()` perspective, we have no effects until now, so we
   will continue the execution.

3. Compute again the `nextLanes`
   
   This is a leftover that should be fixed (until now), but the next lanes
   are computed here again (we computed them first above in the
   `scheduleTaskForRootDuringMicrotask` function.)

   And obviously, if there are `NoLanes`, then `null` is returned

4. Determine if it should `time slice`

   To [use time slicing](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L888)
   , the root should not include [`BlockingLanes`](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L475)
   or [`ExpiredLanes`.](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L491)
   
   Blocking lanes are (per the previous link): `SyncDefaultLanes`,
   `InputContinuousHydrationLane`, `InputContinuousLane`, `DefaultHydrationLane`
   and `DefaultLane`.

   Yes, from `root.render()` without transition we are in `DefaultLane` so this
   render will be considered without time slicing.

5. Call the real render function
   
   Depending on whether it should time slice, it will call `renderRootConcurrent`
   or else it will fall back to `renderRootSync`.

   ```tsx
   let exitStatus = shouldTimeSlice
     ? renderRootConcurrent(root, lanes)
     : renderRootSync(root, lanes);
   ```
6. Finish rendering and perform logic on existStatus

   The possible exitStatus values are [listed here.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L302)
   React will then either [mark the root as suspended](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L903)
   if the render did not complete, or else:
   1. Verify that the render is consistent [with external stores.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L915)
      If not, a sync render [will be performed](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L919)
      
      Then the `while(true)` loop `continue` until a good `existStatus` is
      obtained.
   2. In case of `RootErrored` errors, React will attempt to
      [recover from them if possible.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L936)
      It will attempt to render again [using `renderRootSync`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L997).
   3. If the `exitStatus` is `RootFatalErrored`: TBD, after renderRoot to know why
   4. Or else, then the tree is consistent and the work is considered as finished
      ```tsx
      // simplified
      
      // React when rendering (we will see in the next section) will store
      // the render work output in a property called alternate in each fiber
      // we will see them in details in a few
      const finishedWork: Fiber = root.current.alternate;
      ```
      This variable is then affected to the finishedWork property of the `root`
      and then `finishConcurrentRender` is called.
      ```tsx
      root.finishedWork = finishedWork;
      root.finishedLanes = lanes;
      finishConcurrentRender(root, exitStatus, finishedWork, lanes);
      ```
      // todo: back to this once renderRoot is done

7. Ensure root is scheduled

   We already saw this in the how `root.render()` works section

8. Return a continuation for the root

   todo: after doing renderRoot and probably move this section afterwards

## How `renderRootSync` works

So, we are finally there! The function that renders our components.

```tsx
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  // [Not Native Code]
}
```

### 1. Mark render started
There is a global variable that FiberLoop module uses: `executionContext`, which
is a number used the same way Lanes are used. The possible values [are:](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L297)

```tsx
export const NoContext = /*             */ 0b000;
const BatchedContext = /*               */ 0b001;
export const RenderContext = /*         */ 0b010;
export const CommitContext = /*         */ 0b100;
```

When the `render` starts, the `executionContext` is modified [as follows:](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1838)

```tsx
const prevExecutionContext = executionContext;
executionContext |= RenderContext;

// later, after the render finishes:
executionContext = prevExecutionContext;
```

This variable is so important to React, it can know what kind of work it is
performing and guard against mis-usage.

### 2. Push the context only dispatcher

The React dispatcher is an object having several properties (such as hooks)
that is used by React to propagate behavior like in `dependency injection`
fashioned way.

At this point when the work loop is about to start, this is a transitory phase
and coming from the `root.render` path, a [`ContextOnlyDispatcher`](https://github.com/facebook/react/blob/ddff504695f33c19e8c0792bff82bd8f8b8f7c05/packages/react-reconciler/src/ReactFiberHooks.js#L3296)
is used which will allow only `readContext` and `use`.

The same is done to the upcoming `cache` feature of React, it will have its own
dispatcher.

The dispatchers will be more detailed in their own section.

### 3. Prepare a fresh stack
Next, `renderRoot` will have to check the currently processed root and its lanes
from the global variables against the root that it received from arguments
while scheduling.

You can [see it here.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1503)

```tsx
if (workInProgressRoot !== null || workInProgressRootRenderLanes !== lanes) {
   // some work
   prepareFreshStack(root, lanes);
}
```

Preparing a fresh stack is the process of removing and emptying any information
that was attached during a previous work on the root. Let's dive into it.

- Set the following `root` properties to `null`
  - `finishedWork`
  - `finishedLanes`
  - `timeoutHandle`, will also cancel any existing timeout (to commit)
  - `cancelPendingCommit`
- Reset the work in progress stack
  
  React will do nothing here when coming from `root.render()`, but it will
  reset several Fiber modules and their global variables (their internal state)
  and interrupt any ongoing work. This is normal since we are starting a render
  cycle and things need to [be clean.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1478)
  This process may be the most important and critical to be done correctly.

- Reset the work loop internal state variables

  This involves setting the following variable to their default values:
  - `workInProgressRoot` = `root`
  - `workInProgress` = `createWorkInProgress(root.current, null)`
  - `renderLanes` = `lanes`
  - `workInProgressRootRenderLanes` = `lanes`
  - `workInProgressSuspendedReason` = `NotSuspended`
  - `workInProgressThrownValue` = `null`
  - `workInProgressRootDidAttachPingListener` = `false`
  - `workInProgressRootExitStatus` = `RootInProgress`
  - `workInProgressRootFatalError` = `null`
  - `workInProgressRootSkippedLanes` = `NoLanes`
  - `workInProgressRootInterleavedUpdatedLanes` = `NoLanes`
  - `workInProgressRootRenderPhaseUpdatedLanes` = `NoLanes`
  - `workInProgressRootPingedLanes` = `NoLanes`
  - `workInProgressRootConcurrentErrors` = `null`
  - `workInProgressRootRecoverableErrors` = `null`
  
  The `createWorkInProgress` is very important, so we should [visit it too.](https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiber.js#L269)
  It is responsible for creating a second fiber (the `alternate`) that mirrors
  out FiberNode (`root.current`).

- Finish queuing the concurrent updates

  Do you remember the `concurrentQueues` variable from how `root.render()` works?
  Well, `root.render()` did not do anything to our `root`, but it just
  scheduled its render via microtask queue, and at the same time, it did leave
  the render `children` as an update; like this:
  ```tsx
  concurrentQueues[id++] = fiber;
  concurrentQueues[id++] = sharedQueue;
  concurrentQueues[id++] = update;
  concurrentQueues[id++] = lane;
  ```
  
  Now is time to [process this array](https://github.com/facebook/react/blob/f101c2d0d3a6cb5a788a3d91faef48462e45f515/packages/react-reconciler/src/ReactFiberConcurrentUpdates.js#L50)
  with the following steps:
  - Loop to the end of this array and each time reference the variables using
    the same order we added them, then remove them from the array by setting
    them to `null`.
    ```tsx
    while (i < end) {
      const fiber: Fiber = concurrentQueues[i];
      concurrentQueues[i++] = null;
      const queue: ConcurrentQueue = concurrentQueues[i];
      concurrentQueues[i++] = null;
      const update: ConcurrentUpdate = concurrentQueues[i];
      concurrentQueues[i++] = null;
      const lane: Lane = concurrentQueues[i];
      concurrentQueues[i++] = null;
    
      // at this point the update is attached to fiber's queue, it wasn't before
      if (queue !== null && update !== null) {
        const pending = queue.pending;
        if (pending === null) {
          update.next = update;
        } else {
          update.next = pending.next;
          pending.next = update;
        }
        queue.pending = update;
      }
      if (lane !== NoLane) {
        // this will make use of the fiber, we've already seen it too in
        // the root.render section.
        // it will merge these lanes starting from this fiber to its root
        // (including alternate if present)
        // highlight-next-line
        markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    ```

### 4. Trigger the work loop

Finally, for real this time (almost)! we are there!

React will then start a [`do while(true)`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1877)
loop where it will call `workLoopSync()` (the work loop ðŸ™„). Let's take a look
at the simplified loop:

```tsx
// simplified

do {
  try {
    if (didSuspendDuringHydration) {
      resetWIPStack();
      workInProgressRootExitStatus = RootDidNotComplete;
      break;
    }

     // highlit-next-line
     workLoopSync();
     // Why a break here you wonder ? Hint: there is no break in the catch block
     break;
  } catch (e) {
     // highlit-next-line
     handleThrow(root, e);
  }
} while (true)

```

The [`workLoopSync`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1971)
is defined as:

```tsx
function workLoopSync() {
  // read well the following comment from React codebase, we'll get back to
  // that later
  // highlight-next-line
  // Perform work without checking if we need to yield between fiber.
  while (workInProgress !== null) {
    // highlight-next-line
    performUnitOfWork(workInProgress);
  }
}
```

> This is the actual sync work loop: **Keep performing work until there is
> nothing left to do.**

As you may know already, React will construct a fiber tree from the received
`children` to `root.render` and will keep working until it reaches the end.
How they are linked and how the next fiber is chosen will be detailed in a
separate section, this one is for the loop.



### 5. Handle thrown error
### 6. Restore execution context and dispatcher
### 7. Finish the updates

## How `renderRootConcurrent` works
