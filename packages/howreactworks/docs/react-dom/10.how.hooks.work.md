---
sidebar_position: 10
---

# ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿

## ã¯ã˜ã‚ã«

React v16.8.0 ã§å°å…¥ã•ã‚ŒãŸ[ãƒ•ãƒƒã‚¯](https://react.dev/reference/react/hooks)ã¯ã€React ã‚¢ãƒ—ãƒªã®æ›¸ãæ–¹ã‚’å¤‰é©ã—ã¾ã—ãŸã€‚ãƒ•ãƒƒã‚¯ä»¥å‰ã¯ã€ã‚¹ãƒ†ãƒ¼ãƒˆã‚„ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãƒ­ã‚¸ãƒƒã‚¯ãŒå¿…è¦ãªå ´åˆã€ã‚¯ãƒ©ã‚¹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚ãƒ•ãƒƒã‚¯ã®ç™»å ´ã«ã‚ˆã‚Šã€ãƒ•ã‚¡ãƒ³ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒ React ã‚¢ãƒ—ãƒªé–‹ç™ºã®ãƒ‡ãƒ•ã‚¡ã‚¯ãƒˆã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã¨ãªã‚Šã¾ã—ãŸã€‚

ãƒ•ãƒƒã‚¯ã¯å¤šãã®ã“ã¨ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«ã—ã¾ã—ãŸï¼ˆã‚¯ãƒ©ã‚¹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚ˆã‚Šå„ªã‚Œã¦ã„ã‚‹ã¨è¨€ã£ã¦ã„ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰ã€‚ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æ¨è«–ã‚„æ‰±ã„ã‚’å®¹æ˜“ã«ã—ã€`this`ã®æ‰±ã„ã‹ã‚‰è§£æ”¾ã•ã‚Œã‚‹ãªã©ã®åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚

å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ãƒ•ãƒƒã‚¯è‡ªä½“ã®èª¬æ˜ã¯ååˆ†ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ React å†…éƒ¨ã§ã®å®Ÿè£…æ–¹æ³•ã«ç„¦ç‚¹ã‚’å½“ã¦ã¾ã™ã€‚

## ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

å‰ç« ã®ã€Œãƒ•ã‚¡ãƒ³ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ–¹æ³•ã€ã§ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒåˆå›ãƒã‚¦ãƒ³ãƒˆæ™‚ã‹æ›´æ–°æ™‚ã‹ã«åŸºã¥ã„ã¦`Dispatcher`ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‚’èª¬æ˜ã—ã¾ã—ãŸã€‚ã“ã® Dispatcher ã®æ­£ä½“ã‚’è§£æ˜ã—ã¾ã—ã‚‡ã†ã€‚

## `ReactCurrentDispatcher`

[`renderWithHooks`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L556)é–¢æ•°å†…ã§ã€`ReactCurrentDispatcher.current`ã‚’è¨­å®šã—ã¾ã™ã€‚ã“ã‚Œã¯ React ã®ã™ã¹ã¦ã®ãƒ•ãƒƒã‚¯å®Ÿè£…ã‚’å«ã‚€ãƒ—ãƒ¬ãƒ¼ãƒ³ãª JavaScript ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚

Dispatcher ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç›®çš„ã¯ã€ãƒ•ãƒƒã‚¯ã®ä½¿ç”¨ã‚’åˆ¶é™ã™ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ï¼š

- ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºå¤–ã§ã®ãƒ•ãƒƒã‚¯ä½¿ç”¨ã‚’ç¦æ­¢ï¼ˆæ‰‹å‹•ã§ãƒ•ã‚¡ãƒ³ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‘¼ã³å‡ºã—ãŸå ´åˆãªã©ï¼‰
- ãƒã‚¦ãƒ³ãƒˆæ™‚ã¨æ›´æ–°æ™‚ã§ç•°ãªã‚‹ãƒ•ãƒƒã‚¯ã®æŒ™å‹•ï¼ˆãƒã‚¦ãƒ³ãƒˆæ™‚ã¯ãƒ•ãƒƒã‚¯ã®ä½ç½®ç¢ºä¿ã¨åˆæœŸåŒ–ã€æ›´æ–°æ™‚ã¯æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè¡Œï¼‰

Dispatcher ã«ã¯ React ã®ãƒ•ãƒƒã‚¯ã«å¯¾å¿œã™ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå«ã¾ã‚Œã¾ã™ï¼š

```tsx
export const AllDispatchers: Dispatcher = {
  readContext,

  use,
  useCallback: hook,
  useContext: hook,
  useEffect: hook,
  useImperativeHandle: hook,
  useInsertionEffect: hook,
  useLayoutEffect: hook,
  useMemo: hook,
  useReducer: hook,
  useRef: hook,
  useState: hook,
  useDebugValue: hook,
  useDeferredValue: hook,
  useTransition: hook,
  useSyncExternalStore: hook,
  useId: hook,
};
```

Dispatcher ã«ã¯ã„ãã¤ã‹ã®ç¨®é¡ãŒã‚ã‚Šã¾ã™ãŒã€ä¸»ã« 4 ã¤ã‚’è§£èª¬ã—ã¾ã™ï¼š

- `ContextOnlyDispatcher`: [ã“ã® Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3408)
  ã¯ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºå¤–ã§ã®ãƒ•ãƒƒã‚¯ä½¿ç”¨ã‚’é˜²ãã¾ã™ã€‚ã„ã‚ã‚†ã‚‹ã€ŒInvalid hook callã€[ã‚¨ãƒ©ãƒ¼](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L440)ã‚’ã‚¹ãƒ­ãƒ¼ã—ã¾ã™
- `HooksDispatcherOnMount`: [ã“ã® Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3446)
  ã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒåˆå›ãƒã‚¦ãƒ³ãƒˆã•ã‚Œã‚‹éš›ã®ãƒ•ãƒƒã‚¯å®Ÿè£…ã‚’å«ã¿ã¾ã™
- `HooksDispatcherOnUpdate`: [ã“ã® Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3484)
  ã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹éš›ã®ãƒ•ãƒƒã‚¯å®Ÿè£…ã‚’å«ã¿ã¾ã™
- `HooksDispatcherOnRerender`: [ã“ã® Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3522)
  ã¯ä»¥ä¸‹ã®å ´åˆã®å†ãƒ¬ãƒ³ãƒ€ãƒ¼æ™‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ï¼š
  - ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«çŠ¶æ…‹æ›´æ–°ãŒç™ºç”Ÿã—ãŸå ´åˆ
  - é–‹ç™ºãƒ¢ãƒ¼ãƒ‰ã§ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒ 2 å›ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã‚‹å ´åˆ

## ãƒ•ãƒƒã‚¯ã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°

å„ãƒ•ã‚¡ãƒ³ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ•ãƒƒã‚¯ã‚’å‘¼ã³å‡ºã›ã¾ã™ã€‚ã™ã¹ã¦ã®ãƒ•ãƒƒã‚¯å‘¼ã³å‡ºã—ã¯`renderWithHooks`é–¢æ•°å†…ã§ç™ºç”Ÿã—ã¾ã™ï¼ˆå†ãƒ¬ãƒ³ãƒ€ãƒ¼ç”¨ã®ãƒ•ãƒƒã‚¯ã¯`renderWithHooksAgain`é–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ä¾‹å¤–ã‚’é™¤ãï¼‰ã€‚

ãƒ•ãƒƒã‚¯ã¯[é–¢é€£ã™ã‚‹`Fiber`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L965)ã®`memoizedState`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚

ãƒ•ãƒƒã‚¯ã¯ React å†…éƒ¨ã§ä»¥ä¸‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ãƒ—ãƒ¬ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ä¿å­˜ã•ã‚Œã¾ã™ï¼š

```tsx
const hook: Hook = {
  memoizedState: null,

  baseState: null,
  baseQueue: null,
  queue: null,

  next: null,
};
```

å„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å½¹å‰²ï¼š

- `memoizedState`: ãƒ•ãƒƒã‚¯ã®ã€Œã‚¹ãƒ†ãƒ¼ãƒˆã€ï¼ˆã¾ãŸã¯å€¤ï¼‰ã‚’ä¿æŒ
- `baseState`: ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒƒã‚¯ãŒåˆæœŸå€¤ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã«ä½¿ç”¨
- `baseQueue`:
- `queue`: ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒƒã‚¯ãŒæ§˜ã€…ãªæƒ…å ±ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã® UpdateQueue ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
- `next`: æ¬¡ã®ãƒ•ãƒƒã‚¯ã‚’æŒ‡ã™

`next`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ä½¿ç”¨ã™ã‚‹æ¬¡ã®ãƒ•ãƒƒã‚¯ã‚’å‚ç…§ã™ã‚‹ã“ã¨ã‹ã‚‰ã€ãƒ•ãƒƒã‚¯ã¯å‰è¿°ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆã¨ã—ã¦ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã•ã‚Œã¦ã„ã¾ã™ã€‚

å„ãƒ•ãƒƒã‚¯ã¯ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ä½•ã‚’ä¿å­˜ã™ã‚‹ã‹ã«ã¤ã„ã¦ç‹¬è‡ªã®ä»•æ§˜ã‚’æŒã¡ã€æ˜ã‚‰ã‹ã«ã™ã¹ã¦ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨ã—ãªã„ãƒ•ãƒƒã‚¯ã‚‚ã‚ã‚Šã¾ã™ã€‚

ã“ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«ã¯ãƒ•ãƒƒã‚¯ã®ç¨®é¡ã«é–¢ã™ã‚‹æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚ãƒ•ãƒƒã‚¯ã¯å‘¼ã³å‡ºã—é †åºã«ä¾å­˜ã—ã€å¸¸ã«ä¿å­˜ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

![fiber and hook](imgs/10.fiber_and_hook.png)

Dan Abramov ã¯ã“ã®è¨­è¨ˆé¸æŠã«ã¤ã„ã¦[å„ªã‚ŒãŸãƒ–ãƒ­ã‚°è¨˜äº‹](https://overreacted.io/why-do-hooks-rely-on-call-order/)ã‚’æ›¸ã„ã¦ã„ã¾ã™ã€‚

### ãƒ•ãƒƒã‚¯ã®ä¾‹

ä»¥ä¸‹ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ã¨ä»®å®šã—ã¾ã™ï¼š

```tsx
function MyFunctionComponent(props) {
  const [count, setCount] = React.useState(0);
  // ãƒ‡ãƒ¢ç”¨ã®ãŸã‚å®Ÿéš›ã«ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“
  const isMounted = React.useRef(false);
  // ãƒ‡ãƒ¢ç”¨ã®ãŸã‚å®Ÿéš›ã«ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“
  const mountDate = React.useMemo(() => Date.now(), []);

  React.useEffect(() => {
    function handler() {
      console.log("window is focused");
    }

    window.addEventListener("focus", handler);
    return () => window.removeEventListener("focus", handler);
  }, []);

  return <span>Count is {count}</span>;
}
```

ã“ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ã¨ã€`FunctionComponent`ã‚¿ã‚°ã®`Fiber`ãŒç”Ÿæˆã•ã‚Œã€ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ•ãƒƒã‚¯ã®ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆãŒä½œæˆã•ã‚Œã¾ã™ï¼š

```tsx
let memoizedState = {
  // useState
  memoizedState: 0,
  baseState: 0,
  baseQueue: null,
  queue: {
    pending: null,
    lanes: 0,
    lastRenderedState: 0,
  },
  next: {
    // useRef
    memoizedState: {
      current: false,
    },
    baseState: null,
    baseQueue: null,
    queue: null,
    next: {
      // useMemo
      memoizedState: [1700218172414, []],
      baseState: null,
      baseQueue: null,
      queue: null,
      next: {
        // useEffect
        memoizedState: {
          tag: 9,
          inst: {},
          deps: [],
          next: "the same effect .. removed for clarity",
        },
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null,
      },
    },
  },
};
```

## ãƒã‚¦ãƒ³ãƒˆæ™‚ã®ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿

ãƒã‚¦ãƒ³ãƒˆæ™‚ã®ãƒ•ãƒƒã‚¯ã®ç›®çš„ã¯ã€ãƒªãƒ³ã‚¯ãƒªã‚¹ãƒˆã®ãƒ•ãƒƒã‚¯ã®ä½ç½®ã‚’ç¢ºä¿ã™ã‚‹ã“ã¨ã§ã™ã€‚

ãã®ãŸã‚ã€ã™ã¹ã¦ã®ãƒ•ãƒƒã‚¯å®Ÿè£…ã¯ãƒã‚¦ãƒ³ãƒˆæ™‚ã«ä»¥ä¸‹ã®å‡¦ç†ã‚’æœ€åˆã«è¡Œã„ã¾ã™ï¼š

```tsx
const hook = mountWorkInProgressHook();
```

`mountWorkInProgressHook`é–¢æ•°ã¯å‰è¿°ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆã—ã€ãã‚Œã‚’`currentlyRenderingFiber`ã®`memoizedState`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«è¨­å®šã—ã¾ã™ã€‚

### `mountWorkInProgressHook`ã®å®Ÿè£…

ãƒã‚¦ãƒ³ãƒˆä¸­ã®ãƒ•ãƒƒã‚¯é–¢æ•°ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ï¼š

```tsx
function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,

    baseState: null,
    baseQueue: null,
    queue: null,

    next: null,
  };

  if (workInProgressHook === null) {
    // ã“ã‚Œã¯ãƒªã‚¹ãƒˆã®æœ€åˆã®ãƒ•ãƒƒã‚¯ã§ã™
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // ãƒªã‚¹ãƒˆã®æœ«å°¾ã«è¿½åŠ 
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

- æœ€åˆã«ãƒ•ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™
- ãã®å¾Œã€ãƒªã‚¹ãƒˆã®æœ€åˆã®ãƒ•ãƒƒã‚¯ã§ã‚ã‚‹å ´åˆã€ãã‚Œã‚’`currentlyRenderingFiber`ã®`memoizedState`ã«ã‚¢ã‚¿ãƒƒãƒã—ã€`workInProgressHook`ã«ã‚‚è¨­å®šã—ã¾ã™
- ãã‚Œä»¥å¤–ã®å ´åˆã€`workInProgressHook`ã®`next`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ã‚¢ã‚¿ãƒƒãƒã—ã¾ã™

ä»¥ä¸Šã§ã™ï¼

ãƒ•ãƒƒã‚¯ã«ã‚ˆã£ã¦ã¯ã€ä»–ã®å‡¦ç†ã‚‚è¡Œã‚ã‚Œã¾ã™ãŒã€ãã‚Œãã‚Œã®ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒ•ãƒƒã‚¯ã«ã¤ã„ã¦åˆ¥ã€…ã«èª¬æ˜ã—ã¾ã™ã€‚

## æ›´æ–°æ™‚ã®ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿

ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹ï¼ˆåˆå›ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§ã¯ãªã„ï¼‰å ´åˆã€å„ã‚µãƒãƒ¼ãƒˆã•ã‚Œã‚‹ãƒ•ãƒƒã‚¯å‘¼ã³å‡ºã—ã¯ä»¥ä¸‹ã®å¼ã§å§‹ã¾ã‚Šã€ãã®å¾Œã«ç‰¹å®šã®å‡¦ç†ãŒç¶šãã¾ã™ã€‚

```tsx
const hook = updateWorkInProgressHook();
```

[`updateWorkInProgressHook`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L973)
ã¯ãƒã‚¦ãƒ³ãƒˆã‚ˆã‚Šã‚‚è¤‡é›‘ã§ã™ãŒã€ç›®çš„ã¯æ¬¡ã®`workInProgressHook`ã‚’æ¤œå‡ºã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯æ›´æ–°ã¨å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®ä¸¡æ–¹ã«ä½¿ç”¨ã•ã‚Œã€å‰å›ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‹ã‚‰`current`ãƒ•ãƒƒã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã™ã‚‹ã‹ã€`work-in-progress`ã‚’å†åˆ©ç”¨ã™ã‚‹ã‹ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚

ã“ã®é–¢æ•°ã®æœ€åˆã®éƒ¨åˆ†ã§ã¯ã€ç¾åœ¨ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚ŒãŸãƒ•ãƒƒã‚¯ã®å€¤ã‚’æ¤œå‡ºã—ã¾ã™ã€‚`currentHook`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¤‰æ•°ãŒ null ã®å ´åˆã€`current`ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒãƒ¼ã®`memoizedState`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ãã®`next`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å–å¾—ã—ã¾ã™ï¼š

```tsx
// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã§ï¼š
let currentHook: null | Hook = null;

// updateWorkInProgressHookå†…ã§ï¼š

let nextCurrentHook: null | Hook;
if (currentHook === null) {
  // ç¾åœ¨ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒãƒ¼
  const current = currentlyRenderingFiber.alternate;

  // ã™ã§ã«ãƒã‚¦ãƒ³ãƒˆæ¸ˆã¿ã®å ´åˆ
  if (current !== null) {
    nextCurrentHook = current.memoizedState;
  } else {
    // åˆå›ãƒã‚¦ãƒ³ãƒˆã®å ´åˆ
    nextCurrentHook = null;
  }
} else {
  nextCurrentHook = currentHook.next;
}
```

ã“ã‚Œã§ã€ç¾åœ¨ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ¸ˆã¿ï¼ˆãƒšã‚¤ãƒ³ãƒˆæ¸ˆã¿ï¼‰ãƒ•ãƒƒã‚¯ã®å€¤ã‚’æ¤œå‡ºã—ãŸã®ã§ã€React ã¯æ¬¡ã«ãã®ä»£æ›¿ï¼ˆãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­ã®ã‚‚ã®ï¼‰ã‚’æ¤œå‡ºã—ã¾ã™ï¼š

```tsx
// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã§ï¼š
let workInProgressHook: null | Hook = null;

// updateWorkInProgressHookå†…ã§ï¼š
let nextWorkInProgressHook: null | Hook;

// ãƒªã‚¹ãƒˆã®æœ€åˆã®ãƒ•ãƒƒã‚¯ã®å ´åˆã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒãƒ¼ã‹ã‚‰å–å¾—
if (workInProgressHook === null) {
  nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
} else {
  // ãã‚Œä»¥å¤–ã®å ´åˆã€æ¬¡ã®ãƒ•ãƒƒã‚¯
  nextWorkInProgressHook = workInProgressHook.next;
}
```

ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’æ›´æ–°ã™ã‚‹éš›ã€memoizedState ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã€null ã«è¨­å®šã•ã‚Œã¾ã™ã€‚

ã“ã‚Œã§ã€ç¾åœ¨ã®ãƒšã‚¤ãƒ³ãƒˆæ¸ˆã¿ãƒ•ãƒƒã‚¯ã®å€¤ã¨ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­ã®ã‚‚ã®ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

`nextWorkInProgressHook`ãŒã‚ã‚‹å ´åˆã€ã“ã‚Œã¯ã™ã§ã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é–‹å§‹ã—ã¦ã„ã¦ã€ã‚³ãƒŸãƒƒãƒˆã‚„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®çµ‚äº†ãªã—ã«å†åº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã€ãã®ã¾ã¾å†åˆ©ç”¨ã—ã¾ã™ï¼š

```tsx
if (nextWorkInProgressHook !== null) {
  // ã™ã§ã«ãƒ¯ãƒ¼ã‚¯ã‚¤ãƒ³ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚å†åˆ©ç”¨ã—ã¾ã™ã€‚
  workInProgressHook = nextWorkInProgressHook;
  nextWorkInProgressHook = workInProgressHook.next;

  currentHook = nextCurrentHook;
}
```

ãã‚Œä»¥å¤–ã®å ´åˆã€`nextCurrentHook`ãŒ null ã®å ´åˆã€å‰å›ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚ˆã‚Šã‚‚ãƒ•ãƒƒã‚¯ã‚’å¤šããƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã€ãƒ•ãƒƒã‚¯ã®è¦å‰‡ã«åã™ã‚‹ã“ã¨ã«ãªã‚Šã€React ã¯ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼ã—ã¾ã™ã€‚
`nextCurrentHook`ãŒ null ã§ãªã„å ´åˆã€å‰å›ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®ãƒ•ãƒƒã‚¯ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦åŸºã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š

```tsx
// Reactã®ã‚³ãƒ¼ãƒ‰

if (nextWorkInProgressHook !== null) {
  // å‰ã®ã‚³ãƒ¼ãƒ‰
} else {
  if (nextCurrentHook === null) {
    const currentFiber = currentlyRenderingFiber.alternate;
    if (currentFiber === null) {
      // ã“ã‚Œã¯åˆå›ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§ã™ã€‚ã“ã®ãƒ–ãƒ©ãƒ³ãƒã¯ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒä¸€æ™‚åœæ­¢ã—ã€å†é–‹ã—ã¦ã‹ã‚‰è¿½åŠ ã®ãƒ•ãƒƒã‚¯ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹ã¨ãã«åˆ°é”ã—ã¾ã™ã€‚
      // ã“ã®ãƒ–ãƒ©ãƒ³ãƒã«åˆ°é”ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æœ€åˆã«ãƒã‚¦ãƒ³ãƒˆãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ£ãƒ¼ã«åˆ‡ã‚Šæ›¿ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
      throw new Error(
        "Update hook called on initial render. This is likely a bug in React. Please file an issue."
      );
    } else {
      // ã“ã‚Œã¯æ›´æ–°ã§ã™ã€‚å¸¸ã«ç¾åœ¨ã®ãƒ•ãƒƒã‚¯ãŒã‚ã‚‹ã¯ãšã§ã™ã€‚
      throw new Error("Rendered more hooks than during the previous render.");
    }
  }

  currentHook = nextCurrentHook;

  // ç¾åœ¨ã®ãƒšã‚¤ãƒ³ãƒˆæ¸ˆã¿ãƒ•ãƒƒã‚¯ã‹ã‚‰ã‚¯ãƒ­ãƒ¼ãƒ³
  const newHook: Hook = {
    memoizedState: currentHook.memoizedState,

    baseState: currentHook.baseState,
    baseQueue: currentHook.baseQueue,
    queue: currentHook.queue,

    next: null,
  };

  if (workInProgressHook === null) {
    // ã“ã‚Œã¯ãƒªã‚¹ãƒˆã®æœ€åˆã®ãƒ•ãƒƒã‚¯ã§ã™ã€‚
    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
  } else {
    // ãƒªã‚¹ãƒˆã®æœ«å°¾ã«è¿½åŠ 
    workInProgressHook = workInProgressHook.next = newHook;
  }
}
```

## å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿

ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¨ã„ã†ç”¨èªã¯ã€React ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹å†…ã§ã¯ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ãŸã‹ã€é–‹ç™ºãƒ¢ãƒ¼ãƒ‰ã§å†ç”Ÿã—ã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

`HooksDispatcherOnRerender`ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ£ãƒ¼ã‚’è¦‹ã‚‹ã¨ã€`useReducer: rerenderReducer`, `useState: rerenderState`, `useDeferredValue: rerenderDeferredValue`, `useTransition: rerenderTransition`ä»¥å¤–ã¯`HooksDispatcherOnUpdate`ã¨åŒã˜ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚

ã“ã®ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ£ãƒ¼ã¯[`renderWithHooksAgain`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L771)é–¢æ•°ã‹ã‚‰è¨­å®šã•ã‚Œã¾ã™ã€‚Andrew ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ï¼š

```tsx
// ã“ã‚Œã¯åˆ¥ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã€ã¾ãŸã¯é–‹ç™ºãƒ¢ãƒ¼ãƒ‰ã§ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºã§2å›ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã‚‹ã¨ãã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
//
// å‰å›ã®ãƒ‘ã‚¹ã®çŠ¶æ…‹ã¯å¯èƒ½ãªé™ã‚Šå†åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ãã®ãŸã‚ã€ã™ã§ã«å‡¦ç†ã•ã‚ŒãŸçŠ¶æ…‹æ›´æ–°ã¯å†åº¦å‡¦ç†ã•ã‚Œãšã€ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸé–¢æ•°ï¼ˆ`useMemo`ï¼‰ã¯å†åº¦å‘¼ã³å‡ºã•ã‚Œã¾ã›ã‚“ã€‚
//
// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°ãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œç¶šã‘ã‚‹é™ã‚Šã€ãƒ«ãƒ¼ãƒ—ã§ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’ç¶šã‘ã¾ã™ã€‚ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²ããŸã‚ã«ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
```

## å„ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿

ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ£ãƒ¼ã®å­˜åœ¨é †ã«å¾“ã£ã¦ã€å„ãƒ•ãƒƒã‚¯ã‚’èª¬æ˜ã—ã¾ã™ã€‚

import TBD from "./components/TBDBanner"

## `use`ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿

`use`ãƒ•ãƒƒã‚¯ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’å¾…ã£ã¦ã„ã‚‹é–“ã«ã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹`throw promise`ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç½®ãæ›ãˆã‚‹æ–°ã—ã„ãƒ•ãƒƒã‚¯ã§ã™ã€‚

`throw promise`ã¯é•·ãã‹ã‚‰å­˜åœ¨ã—ã¦ã„ã¾ã—ãŸãŒã€å…¬å¼ã§ã¯ãªãã€ã“ã®ãƒ•ãƒƒã‚¯ã¯å…¬å¼ã®ä»£æ›¿ã¨ã—ã¦å°å…¥ã•ã‚Œã¾ã—ãŸã€‚

### ã‚·ã‚°ãƒãƒãƒ£

`use`ãƒ•ãƒƒã‚¯ã¯[ã“ã“ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1093)ã€‚

```tsx
function use<T>(usable: Usable<T>): T {
  // [Not Native Code]
}
```

Promise ã¾ãŸã¯ Context å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å…¥ã‚Œã¾ã™ã€‚

:::tip
`use`ãƒ•ãƒƒã‚¯ã¯`mountWorkInProgressHook`ã¨`updateWIPHook`ã«ä¾å­˜ã—ãªã„ãŸã‚ã€æ¡ä»¶ä»˜ãã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã€ãƒ•ãƒƒã‚¯ã®è¦å‰‡ã«å¾“ã‚ãªããªã‚Šã¾ã™ã€‚
:::

### å®Ÿè£…

å‰è¿°ã®ã‚ˆã†ã«ã€`use`ã¯`thenabled`ã¨`Context`ã®ä¸¡æ–¹ã‚’å—ã‘å…¥ã‚Œã¾ã™ï¼š

#### Context

`use`ã«æ¸¡ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ React ã®`Context`ã§ã‚ã‚‹å ´åˆã€`readContext`é–¢æ•°ã«å‡¦ç†ã‚’å§”è­²ã—ã¾ã™ã€‚ã“ã‚Œã¯`useContext`ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã—ã¾ã™ã€‚

```tsx
if (
  usable.$$typeof === REACT_CONTEXT_TYPE ||
  usable.$$typeof === REACT_SERVER_CONTEXT_TYPE
) {
  const context: ReactContext<T> = usable;
  return readContext(context);
}
```

ãã®ãŸã‚ã€`use`ã‚’ä½¿ç”¨ã™ã‚‹ã¨æ¡ä»¶ä»˜ãã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–ã§ãã€ãƒ•ãƒƒã‚¯ã®è¦å‰‡ã‚’å›é¿ã§ãã¾ã™ ğŸ¤¯

#### Thenable

Thenable ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæä¾›ã•ã‚ŒãŸå ´åˆã€React ã¯[å†…éƒ¨ã®`useThenable`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1066)é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ï¼š

```tsx
function use<T>(usable: Usable<T>): T {
  if (usable !== null && typeof usable === "object") {
    if (typeof usable.then === "function") {
      const thenable: Thenable<T> = usable;
      return useThenable(thenable);
    }
    // ... other code
  }

  throw new Error("An unsupported type was passed to use(): " + String(usable));
}
```

`useThenable`é–¢æ•°ãŒ`use`ãƒ•ãƒƒã‚¯ã®ä»•äº‹ã®èƒŒå¾Œã«ã‚ã‚‹ã“ã¨ãŒæ˜ã‚‰ã‹ã«ãªã‚Šã¾ã—ãŸã€‚

åˆæœŸåŒ–ã¨ thenable çŠ¶æ…‹ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆï¼ˆã“ã‚Œã«ã¤ã„ã¦ã¯èª¬æ˜ã—ã¾ã›ã‚“ï¼‰ã®å¾Œã€`useThenable`ã¯[`trackUsedThenable`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberThenable.js#L69)ã‚’å‘¼ã³å‡ºã—ã€ã“ã‚ŒãŒã™ã¹ã¦ã®ä»•äº‹ã‚’è¡Œã„ã¾ã™ã€‚

```tsx
function useThenable<T>(thenable: Thenable<T>): T {
  // ã“ã®ãƒ•ã‚¡ã‚¤ãƒãƒ¼å†…ã§thenableã®ä½ç½®ã‚’è¿½è·¡ã—ã¾ã™ã€‚
  const index = thenableIndexCounter;
  thenableIndexCounter += 1;
  if (thenableState === null) {
    // createThenableStateã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ãªJavaScripté…åˆ—ã‚’è¿”ã—ã¾ã™
    thenableState = createThenableState();
  }
  // highlight-next-line
  const result = trackUsedThenable(thenableState, thenable, index);
  // ... other code
  return result;
}
```

ãã‚Œã§ã¯`trackUsedThenable`ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ï¼š

1. ãƒ‘ãƒ¼ãƒˆ 1ï¼šthenable ã‚’é…åˆ—ã«è¿½åŠ ã™ã‚‹

   ã‚½ãƒ•ã‚£ãƒ¼ã®ã‚³ãƒ¡ãƒ³ãƒˆã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚åŒã˜ä½ç½®ã« thenable ãŒã‚ã£ãŸå ´åˆã€æŠ€è¡“çš„ã«ã¯åŒã˜å€¤ã‚’æŒ‡ã™ã¯ãšã§ã™ã®ã§ã€å‰è€…ã‚’å†åˆ©ç”¨ã—ã¾ã™ã€‚ã“ã®è¨­è¨ˆé¸æŠã«ã¤ã„ã¦èã‹ã‚ŒãŸã‚‰ç­”ãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚

   ```tsx
   const previous = thenableState[index];
   if (previous === undefined) {
     thenableState.push(thenable);
   } else {
     if (previous !== thenable) {
       // å‰ã®thenableã‚’å†åˆ©ç”¨ã—ã€æ–°ã—ã„ã‚‚ã®ã‚’æ¨ã¦ã¾ã™ã€‚ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯æ’ç­‰ã§ã‚ã‚‹ã¨ä»®å®šã§ãã¾ã™ã€‚

       // æ„å›³çš„ã«ç„¡è¦–ã™ã‚‹Promiseã®æœªå‡¦ç†ã®æ‹’å¦ã‚¨ãƒ©ãƒ¼ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ãã‚Œã‚‰ã‚’å‡¦ç†ã—ã¾ã™ã€‚
       thenable.then(noop, noop);
       thenable = previous;
     }
   }
   ```

2. ãƒ‘ãƒ¼ãƒˆ 2ï¼šthenable ã‚’è¿½è·¡ã™ã‚‹
   å‰ã« thenable ã‚’è¿½è·¡ã—ãŸã“ã¨ãŒã‚ã‚‹ã‹ã€åˆã‚ã¦é­é‡ã—ãŸã‹ã«ã‚ˆã£ã¦ã€2 ã¤ã®ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚

   thenable ã‚’è¿½è·¡ã™ã‚‹ã“ã¨ã¯ã€thenable è‡ªä½“ã‚’å¤‰æ›´ã™ã‚‹`then(onFullfilement, onRejection)`ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ï¼š

   ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚ˆãèª­ã‚“ã§ç†è§£ã—ã¦ãã ã•ã„ï¼š

   ```tsx
   const pendingThenable: PendingThenable<T> = thenable;
   pendingThenable.status = "pending";
   pendingThenable.then(
     (fulfilledValue) => {
       if (thenable.status === "pending") {
         const fulfilledThenable: FulfilledThenable<T> = thenable;
         fulfilledThenable.status = "fulfilled";
         fulfilledThenable.value = fulfilledValue;
       }
     },
     (error: mixed) => {
       if (thenable.status === "pending") {
         const rejectedThenable: RejectedThenable<T> = thenable;
         rejectedThenable.status = "rejected";
         rejectedThenable.reason = error;
       }
     }
   );
   ```

   ã—ã‹ã—ã€thenable ãŒæ—¢ã«è¿½è·¡ã•ã‚Œã¦ã„ã‚‹å ´åˆã€å˜ã«ãã®çŠ¶æ…‹ã‚’ç¢ºèªã—ã¾ã™ï¼š

   ```tsx
   switch (thenable.status) {
     case "fulfilled": {
       const fulfilledValue: T = thenable.value;
       return fulfilledValue;
     }
     case "rejected": {
       const rejectedError = thenable.reason;
       checkIfUseWrappedInAsyncCatch(rejectedError);
       throw rejectedError;
     }
     // ... other code
   }
   ```

   - çŠ¶æ…‹ãŒ`fulfilled`ã®å ´åˆã€`use`ãƒ•ãƒƒã‚¯ã¯å€¤ã‚’è¿”ã—ã¾ã™
   - çŠ¶æ…‹ãŒ`rejected`ã®å ´åˆã€`use`ãƒ•ãƒƒã‚¯ã¯ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼ã—ã¾ã™

   çŠ¶æ…‹ãŒ`pending`ã®å ´åˆã€React ã¯ç‰¹åˆ¥ãªä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹`SuspenseException`ã‚’ã‚¹ãƒ­ãƒ¼ã—ã€thenable ãŒè§£æ±ºã¾ãŸã¯æ‹’å¦ã•ã‚Œã‚‹ã¾ã§ãƒ„ãƒªãƒ¼ã‚’ä¸€æ™‚åœæ­¢ã—ã¾ã™ã€‚

   ã“ã‚Œã«ã‚ˆã‚Šã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã«ã®ã¿ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ã‚¹ãƒ­ãƒ¼ã•ã‚Œã¾ã™ã€‚

   :::note
   `use`ãƒ•ãƒƒã‚¯ã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒã™ã‚‹ãŸã‚ã«ãƒ„ãƒªãƒ¼ã«ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒªã‚’é…ç½®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
   :::

:::warning
`use`ãƒ•ãƒƒã‚¯ã¯ã€æ‰‹å‹•ã§ãƒ—ãƒ­ãƒŸã‚¹ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥/ãƒ¡ãƒ¢åŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

`React.cache`å®Ÿé¨“çš„ãª API ã¯ã€ã“ã‚Œã‚’åŠ©ã‘ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã—ã¦ã„ã¾ã™ã€‚
:::

### ä¾‹

jsonplaceholder ã®å…¬é–‹ API ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è©³ç´°ã‚’å–å¾—ã™ã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¾ã™ã€‚

ã“ã‚Œã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã€å˜ç´”ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½œæˆã—ã¦ã€ãƒ—ãƒ­ãƒŸã‚¹ã‚’ãƒ¡ãƒ¢åŒ–ã—ã€ç„¡é™ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é¿ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã“ã§ã€é–¢æ•°ç”¨ã®ãƒ€ãƒŸãƒ¼ãƒ¡ãƒ¢ãƒ©ã‚¤ã‚¶ãƒ¼ã‚’ä½œæˆã—ã¾ã™ï¼š

```tsx
// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ã¯1ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹ã¨ä»®å®šã—ã¾ã™
// ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§ã™ã€‚
// React.cacheã¯ã“ã‚Œã‚’è§£æ±ºã™ã‚‹ä¸€èˆ¬çš„ãªã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚
// æ˜ç¢ºã«ã™ã‚‹ãŸã‚ã€userIdã®ã¿ã‚’ä½¿ç”¨ã—ã¾ã™
function createCache(asyncFunc) {
  let cache = {};

  return function exec(...args) {
    let cacheId = args[0];
    let existing = cache[cacheId];
    if (existing) {
      return existing;
    }

    let result = asyncFunc.apply(null, args);
    cache[cacheId] = result;
    return result;
  };
}
```

æ¬¡ã«ã€ãƒ€ãƒŸãƒ¼ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒªã‚’ä½œæˆã—ã¾ã™ï¼š

```tsx
class ErrorBoundary extends React.Component {
  state = { error: null };
  componentDidCatch(error) {
    this.setState((prev) => ({ ...prev, error }));
  }
  render() {
    const { error } = this.state;
    if (error) {
      return (
        <>
          <pre>{error.toString()}</pre>
          <button
            onClick={() => this.setState((prev) => ({ ...prev, error: null }))}
          >
            Reset
          </button>
        </>
      );
    }
    return this.props.children;
  }
}
```

æœ€å¾Œã«ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’åˆ©ç”¨ã—ã¾ã™ï¼š

```tsx
async function fetchUserById(userId) {
  let result = await axios.get(
    `https://jsonplaceholder.typicode.com/users/${userId}`
  );
  return result.data;
}

let getUserDetails = createCache(fetchUserById);

let IDS = [1, 2, 3, 4, 5, 10, 11];

function UserDetails({ id }) {
  let details = React.use(getUserDetails(id));

  return (
    <details open>
      <pre>{JSON.stringify(details, null, 4)}</pre>
    </details>
  );
}
function Example() {
  let [userId, setUserId] = React.useState(IDS[0]);
  return (
    <div className="App">
      {IDS.map((id) => (
        <button
          onClick={() => {
            setUserId(id);
          }}
          key={id}
        >
          {`User ${id}`}
        </button>
      ))}
      <React.Suspense fallback={`Loading user ${userId}`}>
        <UserDetails id={userId} />
      </React.Suspense>
    </div>
  );
}

export default function App() {
  return (
    <ErrorBoundary>
      <Example />
    </ErrorBoundary>
  );
}
```

ã“ã®[ãƒ‡ãƒ¢](https://codesandbox.io/s/lucid-curran-x8xxlj?file=/src/App.js)ã‚’è¡¨ç¤ºã—ã¦æ“ä½œã§ãã¾ã™ï¼š

<iframe src="https://codesandbox.io/embed/lucid-curran-x8xxlj?fontsize=14&hidenavigation=1&theme=dark"
style={{width: "100%", height: "500px", border: 0, borderRadius: 4}}
title="React.use demo"
allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>

## `useCallback`ãƒ•ãƒƒã‚¯ã®ä»•çµ„ã¿

`useCallback`ãƒ•ãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ä¾å­˜é–¢ä¿‚ãŒå¤‰æ›´ã•ã‚Œã‚‹ã¾ã§é–¢æ•°å‚ç…§ã‚’ä¿æŒã§ãã¾ã™ã€‚

### ã‚·ã‚°ãƒãƒãƒ£

`useCallback`ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ï¼š

```tsx
function useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

ç›´æ¥çš„ã«ã¯å­˜åœ¨ã—ãªã„é–¢æ•°ã§ã™ãŒã€å‰è¿°ã®ã‚ˆã†ã«[`mountCallback`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2602)ã¨[`updateCallback`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2609)é–¢æ•°ãŒã‚ã‚Šã€åŒã˜ã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã¡ã¾ã™ï¼š

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

### å®Ÿè£…

#### ãƒã‚¦ãƒ³ãƒˆæ™‚

ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæœ€åˆã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã‚‹ã¨ãã«`useCallback`ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€å‘¼ã³å‡ºã—ã¯`mountCallback`ã«ã‚ˆã£ã¦ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ãƒˆã•ã‚Œã€æœ€ã‚‚ç°¡å˜ãªãƒ•ãƒƒã‚¯ã§ã™ï¼š

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // ã‚¹ãƒ†ãƒƒãƒ—1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // ã‚¹ãƒ†ãƒƒãƒ—2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // ã‚¹ãƒ†ãƒƒãƒ—3
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **ã‚¹ãƒ†ãƒƒãƒ— 1**ï¼šå‰è¿°ã®ãƒ•ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ãƒã‚¦ãƒ³ãƒˆã—ã¾ã™
- **ã‚¹ãƒ†ãƒƒãƒ— 2**ï¼šä¾å­˜é–¢ä¿‚ã‚’å®šç¾©ã—ã¾ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã¯`null`ã‚’ä½¿ç”¨ã—ã¾ã™
- **ã‚¹ãƒ†ãƒƒãƒ— 3**ï¼šã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ä¾å­˜é–¢ä¿‚ã‚’ãƒ•ãƒƒã‚¯ã®`memoizedState`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«æ ¼ç´ã—ã¾ã™

`useCallback`ã¯æ¸¡ã•ã‚ŒãŸå€¤ã‚’ãã®ã¾ã¾è¿”ã—ã¾ã™ã€‚é€šå¸¸ã€ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³é–¢æ•°ã‚’ç›´æ¥å®šç¾©ã™ã‚‹ã‹ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ¬ä½“å†…ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã‚’æ¸¡ã—ã¾ã™ã€‚

ãƒã‚¦ãƒ³ãƒˆæ™‚ã«`useCallback`ã¯ä¾å­˜é–¢ä¿‚ã«ã¤ã„ã¦ã¯é–¢å¿ƒãŒã‚ã‚Šã¾ã›ã‚“ã€‚å˜ã«ãã‚Œã‚‰ã‚’å¾Œã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã«æ ¼ç´ã™ã‚‹ã ã‘ã§ã™ã€‚

#### æ›´æ–°æ™‚

æ›´æ–°æ™‚ã€ç›®çš„ã¯ä¾å­˜é–¢ä¿‚ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã«ã®ã¿æ–°ã—ã„é–¢æ•°å‚ç…§ã‚’ä¸ãˆã‚‹ã“ã¨ã§ã™ã€‚

```tsx
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // ã‚¹ãƒ†ãƒƒãƒ—1
  // highlight-next-line
  const hook = updateWorkInProgressHook();
  // ã‚¹ãƒ†ãƒƒãƒ—2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  // ã‚¹ãƒ†ãƒƒãƒ—3
  // highlight-next-line
  if (nextDeps !== null) {
    const prevDeps: Array<mixed> | null = prevState[1];
    // ã‚¹ãƒ†ãƒƒãƒ—4
    // highlight-next-line
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  // ã‚¹ãƒ†ãƒƒãƒ—5
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **ã‚¹ãƒ†ãƒƒãƒ— 1**ï¼šãƒ•ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã¾ãŸã¯å†åˆ©ç”¨ã—ã¾ã™
- **ã‚¹ãƒ†ãƒƒãƒ— 2**ï¼šä¾å­˜é–¢ä¿‚é…åˆ—ã‚’æ¨è«–ã—ã¾ã™ã€‚æŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯`null`ã‚’ä½¿ç”¨ã—ã¾ã™
- **ã‚¹ãƒ†ãƒƒãƒ— 3**ï¼šä¾å­˜é–¢ä¿‚ãŒ null ã§ãªã„å ´åˆï¼ˆundefined ã‚’æŒ‡å®šã™ã‚‹ã¨ãƒ¡ãƒ¢åŒ–ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ï¼‰ã€å‰ã®ä¾å­˜é–¢ä¿‚ã¨æ¯”è¼ƒã—ã¾ã™
- **ã‚¹ãƒ†ãƒƒãƒ— 4**ï¼šå‰ã®ä¾å­˜é–¢ä¿‚ã¨æ¬¡ã®ä¾å­˜é–¢ä¿‚ã‚’æ¯”è¼ƒã—ã€åŒã˜å ´åˆã¯å‰ã®å€¤ï¼ˆ`memoizedState`é…åˆ—ã®æœ€åˆã®è¦ç´ ï¼‰ã‚’è¿”ã—ã¾ã™ã€‚æ¯”è¼ƒæ–¹æ³•ã¯å¾Œã§èª¬æ˜ã—ã¾ã™
- **ã‚¹ãƒ†ãƒƒãƒ— 5**ï¼šä¾å­˜é–¢ä¿‚ãŒå¤‰æ›´ã•ã‚ŒãŸã‹ã€ãƒ¡ãƒ¢åŒ–ã—ã¦ã„ãªã„å ´åˆã€`mountCallback`ã¨åŒæ§˜ã«`[callback, nextDeps]`ã‚’ãƒ•ãƒƒã‚¯ã®`memoizedState`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«æ ¼ç´ã—ã¾ã™

The [`areHookInputsEqual`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L451)
é–¢æ•°ã¯ä¾å­˜é…åˆ—ã‚’ä½¿ç”¨ã™ã‚‹ã™ã¹ã¦ã®ãƒ•ãƒƒã‚¯ã§ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ï¼š

- å‰å›ã®ä¾å­˜é…åˆ—ãŒãªã„å ´åˆã€å¸¸ã«`false`ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Š React ã¯ãƒ•ãƒƒã‚¯ã®è¿”ã‚Šå€¤ã‚’å†è¨ˆç®—ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ä¾å­˜é…åˆ—ãŒç©ºï¼ˆ`[]`ï¼‰ã®å ´åˆã€æ¯å›ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ã§æ›´æ–°ã•ã‚Œã¾ã™
- ä¸¡æ–¹ã®é…åˆ—ã‚’ãƒ«ãƒ¼ãƒ—ã—ã€`Object.is`ã§å€‹ã€…ã®å€¤ã‚’æ¯”è¼ƒã—ã¾ã™

## How useContext works

The [`useContext` hook](https://react.dev/reference/react/useContext) allows you
to read and subscribe to a [React Context](https://medium.com/@mohamedelayadi/react-context-all-you-need-to-know-40de6662b074)
value.

### Signature

[`useContext` hook](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L713)
is defined as follows:

```tsx
function readContext<T>(context: ReactContext<T>): T {
  // [Not Native Code]
}
```

Where the unique parameter refers to a React context object created by the
[`React.createContext` API.](https://react.dev/reference/react/createContext)

### Implementation

`useContext` uses the [`readContextForConsumer`](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L740)
function:

```tsx
export function readContext<T>(context: ReactContext<T>): T {
  // ...dev checks
  return readContextForConsumer(currentlyRenderingFiber, context);
}
```

The `readContextForConsumer` is responsible for giving you the current context
value and also subscribe to it for future changes. Let's dig into its
implementation:

```tsx
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>
): T {
  // step 1
  // highlight-next-line
  const value = isPrimaryRenderer
    ? context._currentValue
    : context._currentValue2;

  // step 2
  // highlight-next-line
  if (lastFullyObservedContext === context) {
    // Nothing to do. We already observe everything in this context.
    // step 3
    // highlight-next-line
  } else {
  }
}
```

- **Step 1**: Decides on the internal context value based on the
  `isPrimaryRenderer` renderer property. I don't have much experience with this
  property, but you set it while creating a custom React renderer. Primary means
  that your renderer renders the whole page, and secondary means that you are
  writing a renderer meant to be used on top of another one. In our case, which
  is React-DOM, it is a primary renderer, so we take the `_currentValue` value.
- **Step 2**: The second step will actually bail out reading and subscribing to
  this context. React uses the `lastFullyObservedContext` module variable, which
  [seems to be unused](https://github.com/search?q=repo%3Afacebook%2Freact%20lastFullyObservedContext&type=code).
  I haven't seen it being written in the whole codebase.
- **Step 3**: The third step is where subscription occurs, let's dig into it.

### How Context subscription works

The context subscription is stored in the `fiber.dependencies` property in
a linked list fashion (again):

```tsx
// simplified
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>
): T {
  const value = context._currentValue;

  const contextItem = {
    context: context as ReactContext<any>,
    memoizedValue: value,
    next: null,
  };
}
```

Then, when this is the first `useContext` in this component, it will add the
following object as `dependencies`:

```tsx
// simplified

// the lastContextDependency variable is reset in the prepareToReadContext
// function called when we are about to update components
// (updateFunctionComponent and others)
if (lastContextDependency === null) {
  lastContextDependency = contextItem;
  // consumer is the work in progress fiber
  consumer.dependencies = {
    lanes: NoLanes,
    firstContext: contextItem,
  };
}
```

Or else, it will add the context item as the `next` property of the previous one:

```tsx
if (lastContextDependency === null) {
  // ...
} else {
  lastContextDependency = lastContextDependency.next = contextItem;
}
```

And that's it!

### Updates

When a component rendering a `ContextProvider` gets updated, React will check
on the `value` `prop`, and if it changed, it will propagate the changes.

This section will be explained in how rendering of a `ContextProvider` works.

:::note
Similarly to the `use` hook, `useContext` can be called conditionally on render.

But you cannot call it inside other hooks or outside the render phase. Because
it needs the currently rendering fiber to be able to perform subscription.
:::

## How useEffect works

[The `useEffect` hook](https://react.dev/reference/react/useEffect) allows you
to register passive effects on your component.

Passive effects run as the last part of the `commit` phase of the render.
It is either synchronous for `SyncLane`s for `Asynchronous` for the rest lanes.

From the docs:

> useEffect is a React Hook that lets you synchronize a component with an
> external system.

This means that you should **only** use this hook to keep your component in sync
with external systems, such as the browser APIs (focus, resize, blur...) or
some external stores.

### Signature

The `useEffect` hooks is defined as follows:

```tsx
function useEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

It accepts two parameters:

- `create`: the effect creation function, it doesn't accept any parameters, and
  return either nothing, or a `cleanup` function. The cleanup function is
  responsible for cleaning the effect work: such as unsubscribing from an event.
- `deps`: The optional dependencies array, that will result in running the
  effect creation again whenever a dependency changes. If this parameter is
  omitted, the effect will run at **the end of every render phase.**

:::note
If your component performs a render phase state update, the effect won't run
twice. But rather, the effects are ran at the commit phase, after the render is
performed.
:::

### Implementation on mount

Like normal hooks, this hook relies on `mountWorkInProgressHook()`, which
creates the object seen in the start of this section.
`mountEffect` calls a function called `mountEffectImpl`.

:::note
`mountEffectImpl` is called from all the other effect hooks (`useLayoutEffect`,
`useInsertionEffect` and other hooks that add special effects.)
:::

```tsx
function mountEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  mountEffectImpl(
    PassiveEffect | PassiveStaticEffect,
    HookPassive,
    create,
    deps
  );
}
```

Let's discuss the previous snippet before going any longer, to do so, we need
to observe the [`mountEffectImpl` signature:](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2331)

```tsx
function mountEffectImpl(
  fiberFlags: Flags,
  hookFlags: HookFlags,
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

- `fiberFlags`: Flags that will be added to the component using the effect
- `hookFlags`: Flags that define [the effect itself](https://github.com/facebook/react/blob/9cdf8a99edcfd94d7420835ea663edca04237527/packages/react-reconciler/src/ReactHookEffectTags.js#L10),
  possible values are: `Insertion`, `Layout` and `Passive`. `Passive` is used
  for `useEffect`.
- `create`: The effect function
- `deps`: The effect dependencies

Finally, let's take a look at the `useEffectImpl` function before diving more
in this maze:

```tsx
function mountEffectImpl(
  fiberFlags: Flags,
  hookFlags: HookFlags,
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // step 1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // step 2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // step 3
  // highlight-next-line
  currentlyRenderingFiber.flags |= fiberFlags;
  // step 4
  // highlight-next-line
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    createEffectInstance(),
    nextDeps
  );
}
```

- **Step 1**: Mount the hook data structure seen in the top of this section
- **Step 2**: Define the dependencies to use, if the parameter is omitted, `null`
  is used.
- **Step 3**: Add the received fiberFlags to the currently rendering fiber. In
  the case of `useEffect`, it is: `PassiveEffect | PassiveStaticEffect`, which
  is a natural number (`8390656` at the moment of writing these words).
- **Step 4**: Store the `memoizedState` value of this hook, which is the result
  of calling the `pushEffect`.

The [`createEffectInstance` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2236)
just returns the object `{ destroy: undefined }`. It will be used to store the
effect cleanup function (if any).

So, the last part of this is to take a look at the [`pushEffect` function:](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2202)

```tsx
function pushEffect(
  tag: HookFlags, // useEffect: Passive
  create: () => (() => void) | void,
  inst: EffectInstance, // { destroy: undefined }
  deps: Array<mixed> | null
): Effect {
  // [Not Native Code]
}
```

#### Create the effect object

This object is created every render for every effect you use, it stores the
relevant information needed to perform well.

```tsx
const effect: Effect = {
  tag, // The hook flag
  create, // the provided effect function
  inst, // { destroy: undefined }
  deps, // the provided dependencies or null
  // Circular
  next: null, // this will be set next
};
```

#### Link the effect to the function component update queue

Next, React will reference the `currentlyRenderingFiber.updateQueue` property,
and if null, it will initialize it:

```tsx
let componentUpdateQueue: null | FunctionComponentUpdateQueue =
  currentlyRenderingFiber.updateQueue;
if (componentUpdateQueue === null) {
  componentUpdateQueue = createFunctionComponentUpdateQueue();
  currentlyRenderingFiber.updateQueue = componentUpdateQueue;
  // this creates a circular reference (it will be teared a part when committing)
  componentUpdateQueue.lastEffect = effect.next = effect;
}
```

The update queue created by `createFunctionComponentUpdateQueue` looks like this:

```tsx
const updateQueue = {
  lastEffect: null,
  events: null,
  stores: null,
};

// when the memoCache feature is enabled, it will add a memoCache property
// initialized by null
```

It is used as a circular linkedList, when we store the lastEffect (its `next`
property will then point to the `first` effect in the list.)

When the component `updateQueue` is already initialized (we've called an
effect before in this render, or another hook initialized it), React will take
the `lastEffect` property and:

- If `null` (may happen if the updateQueue was initialized by events or stores
  and not by an effect), it will do the same as before: will create a circular
  reference by the `effect` object and itself, and store it in the `lastEffect`
  property of the queue.
  ```tsx
  const lastEffect = componentUpdateQueue.lastEffect;
  if (lastEffect === null) {
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    // take a look next
  }
  ```
- Not `null` means that we called an effect hook before in this render pass,
  and in this case, React will execute this code:
  ```tsx
  const firstEffect = lastEffect.next;
  lastEffect.next = effect;
  effect.next = firstEffect;
  componentUpdateQueue.lastEffect = effect;
  ```
  Don't be confused, let's break the previous code:
  - First, reference the first effect on the list (well, since it is a circular
    linked list, the first is the `next` of the last).
  - Add the new effect as the `next` of the previous `lastEffect`: well, this is
    the new last.
  - The new effect (which is the new last) will point then to the `firstEffect`
    in its `next` property.
  - Finally, mark the new effect as the lastEffect in the list in the component
    `updateQueue`.

Finally, the `pushEffect` function will return the new effect object defined
below and store it in the `hook.memoizedState`.

### Implementation on update

On updates, `useEffect` will [call `updateEffect`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2407)
from the`HooksDispatcherOnUpdate` dispatcher, which will delegate to the
[`updateEffectImpl` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2348).

:::note
These functions have the same signature as the mount ones.

The only difference to note is the passed `fiberFlags`: On mount we passed
`PassiveEffect | PassiveStaticEffect`, and on update we pass only `PassiveEffect`.

At the moment of writing these words, I cannot seem to know what causes this
difference, I cannot find any place in [the React codebase](https://github.com/search?q=repo%3Afacebook%2Freact%20PassiveStatic&type=code)
where the`PassiveStaticEffect` is used to build any decision. Apart from some
todos, so maybe an incoming/unfinished feature.

But there is also the following comment where static [flags are declared:](https://github.com/facebook/react/blob/768f965de2d4c6be7f688562ef02382478c82e5b/packages/react-reconciler/src/ReactFiberFlags.js#L59)

```tsx
// Static tags describe aspects of a fiber that are not specific to a render,
// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
// This enables us to defer more work in the unmount case,
// since we can defer traversing the tree during layout to look for Passive effects,
// and instead rely on the static flag as a signal that there may be cleanup work.
export const RefStatic = /*                    */ 0b0000001000000000000000000000;
export const LayoutStatic = /*                 */ 0b0000010000000000000000000000;
export const PassiveStatic = /*                */ 0b0000100000000000000000000000;
export const MaySuspendCommit = /*             */ 0b0001000000000000000000000000;
```

:::

In addition to passed parameters, the implementation surely differ, because
on updates, we need to check if dependencies changed:

So, first, the `updatewWorkInProgressHook` function is called.

```tsx
function updateEffectImpl(
  fiberFlags: Flags, // PassiveEffect
  hookFlags: HookFlags, // HookPassive for useEffect
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  // the effect from the previous render
  const effect: Effect = hook.memoizedState;
  // the effect instance from the previous render, it will be reused
  const inst = effect.inst;

  // currentHook is null on initial mount when rerendering after a render phase
  // state update or for strict mode.
  // we've seen currentHook at the start of this section, in updateWIPHook
  if (currentHook !== null) {
    if (nextDeps !== null) {
      const prevEffect: Effect = currentHook.memoizedState;
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // pushEffect was described on mount above, we call it here too
        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);
        return;
      }
    }
  }

  // add the fiberFlags to the fiber.flags
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    inst,
    nextDeps
  );
}
```

:::tip
This is how useEffect works, the effect functions are executed in the commit
phase. During render, we just store the relevant information.

Please refer to the [`how commit works` section](/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works)
for more information about the timing of invocation of each type of effects.
:::

## How useImperativeHandle works

The [`useImperativeHandle` hook](https://react.dev/reference/react/useImperativeHandle)
is defined in the official docs as:

> useImperativeHandle is a React Hook that lets you customize the handle exposed
> as a ref.

In human words for the rest of us, this means that it lets you override what
a component is exposing as ref (the handle), for example, if you want to add a
function to your custom button, let's say, you want to add a `sayHiTo(name)`
function to it that will show an `alert`, and so on.

### Signature

The `useImerativeHandle` is defined as follows:

```tsx
function mountImperativeHandle<T>(
  ref: { current: T | null } | ((inst: T | null) => mixed) | null | void,
  create: () => T,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

- **ref**: The ref, created by `useRef` or `createRef`, can be also a ref
  callback
- **create**: The function that will return the new ref '`handle`'
- **deps**: The hook dependencies, the create function will be called again
  when a dependency changes.

### Implementation on mount

When the component using `useImperativeHandle` renders for the first time,
it will call the [`mountImperativeHandle` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2533)
which is implemented as follows:

```tsx
// step 1
// highlight-next-line
const effectDeps =
  deps !== null && deps !== undefined ? deps.concat([ref]) : null;
// step 2
// highlight-next-line
mountEffectImpl(
  UpdateEffect | LayoutStaticEffect,
  HookLayout,
  imperativeHandleEffect.bind(null, create, ref),
  effectDeps
);
```

- **Step 1**: Compute the real hook dependencies: The provided ones in addition
  to the ref object itself. Maybe we can skip adding the ref to the array and
  suppose the developer should add it manually ? But this won't be backward
  compatible anyway.
- **Step 2**: The second step is to mount an effect (wait! what ? ğŸ˜³)

Yes, you've read that right, `useImperativeHandle` will insert a special layout
effect whose `create` function is the [`imperativeHandleEffect` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2503)

:::tip
During the commit phase, React will attach refs at the `Layout` phase. That's
why the whole work is used as a layout effect.
:::

### Implementation on update

On updates, `useImperativeHandle` will calculate the deps like on mount,
and then call to `updateEffectImpl` with only `UpdateEffect` as fiber flags.

This brings us to the real work.

### How `imperativeHandleEffect` works

#### Signature

```tsx
function imperativeHandleEffect<T>(
  create: () => T,
  ref: { current: T | null } | ((inst: T | null) => mixed) | null | void
): void | (() => void) {
  // [Not Native Code]
}
```

#### Implementation

The implementation will perform the work based on whether the passed ref is
a ref object or a ref callback, and either ways will call your passed `create`
function and return a cleanup function for the layout effect:

```tsx
if (typeof ref === "function") {
  // step 1
  // highlight-next-line
  const refCallback = ref;
  // step 2
  // highlight-next-line
  const inst = create();
  // step 3
  // highlight-next-line
  refCallback(inst);
  // step 4
  // highlight-next-line
  return () => {
    refCallback(null);
  };
}
```

- **Step 1**: keep track of the passed ref callback reference
- **Step 2**: call the useImperativeHandle create function, that will produce
  the new ref handle
- **Step 3**: call the ref callback with the resulting handle
- **Step 4**: return the layout effect cleanup to call the ref callback again
  with a null value

Alternatively, when the passed `ref` is a `refObject`, then
`imperativeHandleEffect` will:

```tsx
// this is origannly an else if
if (ref !== null && ref !== undefined) {
  // step 1
  // highlight-next-line
  const refObject = ref;
  // step 2
  // highlight-next-line
  const inst = create();
  // step 3
  // highlight-next-line
  refObject.current = inst;
  // step 4
  // highlight-next-line
  return () => {
    refObject.current = null;
  };
}
```

- **Step 1**: keep track of the passed ref object reference
- **Step 2**: call the useImperativeHandle create function, that will produce
  the new ref handle
- **Step 3**: attach the resulting ref handle to the `current` property of the
  ref object
- **Step 4**: return the layout effect cleanup that will reset the `current`
  property to null

And that's it!

:::note
As stated before, the `imperativeHandleEffect` will be invoked during the
layout effect iteration of the commit phase. It won't be called right away
during render.
:::

## How useInsertionEffect works

The [`useInsertionEffect` hook](https://react.dev/reference/react/useInsertionEffect)
by definition:

> Allows inserting elements into the DOM before any layout effects fire

As stated in its official documentation section, it should only be used by
css-in-js library authors, if not, please use `useLayoutEffect` or `useEffect`.

### Signature

Same as other effects, the `useInsertionEffect` is defined as follows:

```tsx
function useInsertionEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

### Implementation

The `useInsertionEffect` implementation is the [same as `useEffect`](#how-useeffect-works),
the only difference is the `flags` being passed on mount to `mountEffectImpl`
and on update to `updateEffectImpl`:

- On mount: React passes `UpdateEffect` as fiber flags and `HookInsertion` as
  hook flags.
- On update: React passes `UpdateEffect` as fiber flags and `HookInsertion` as
  hook flags.

And that's it! All effects only differ in the flags.

## How useLayoutEffect works

The [`useLayoutEffect` hook](https://react.dev/reference/react/useLayoutEffect)
by definition is:

> Is a version of useEffect that fires before the browser repaints the screen.

Well, that's not totally true when it comes to comparing it to useEffect,
the [`how commit works` section](/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works)
will reveal more information about that.

`useLayoutEffect` allows you to register effect that run after the render phase
synchronously after mutating the dom elements.

Its synchronous nature blocks the browser's main thread and thus prevent it from
partially painting the new render resulting UI. Which makes us often say:
`useLayoutEffect` runs before the browser's paint.

`useLayoutEffect` runs at the same time as `ClassComponent` lifecycle methods
(`componentDidMount` and `componentDidUpdate`)

### Signature

Same as other effects, the `useInsertionEffect` is defined as follows:

```tsx
function useLayoutEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

### Implementation

The `useLayoutEffect` implementation is the [same as `useEffect`](#how-useeffect-works),
the only difference is the `flags` being passed on mount to `mountEffectImpl`
and on update to `updateEffectImpl`:

- On mount: React passes `UpdateEffect | LayoutStaticEffect` as fiber flags and
  `HookLayout` as hook flags.
- On update: React passes `UpdateEffect` as fiber flags and `HookLayout` as
  hook flags.

And that's it! All effects only differ in the flags.

## How useMemo works

The [`useMemo` hook](https://react.dev/reference/react/useMemo) allows you to
cache a value until a dependency changes.

### Signature

`useMemo` is defined as follows:

```tsx
function useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

Where:

- **`nextCreate`**: The function that will output our cached value
- **`deps`**: The dependencies

### Implementation on mount

On mount, `useMemo` will [call `mountMemo`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2623)
which is defined as follows:

```tsx
function mountMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null
): T {
  // step 1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // step 2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // step 3
  // highlight-next-line
  const nextValue = nextCreate();
  // step 4
  // highlight-next-line
  hook.memoizedState = [nextValue, nextDeps];
  // step 5
  // highlight-next-line
  return nextValue;
}
```

- **Step 1**: create the hook object on mount
- **Step 2**: calculate the deps to use, either the provided ones or `null`
- **Step 3**: calculate the initial memo value
- **Step 4**: store `[nextvalue, nextDeps]` as the `memoizedState` of the hook
- **Step 5**: return the cached value

:::note
When in development mode and under StrictMode, React will call the `nextCreate`
twice:

```tsx
// initialized in the renderWithHooks function
if (shouldDoubleInvokeUserFnsInHooksDEV) {
  nextCreate();
}
```

:::
