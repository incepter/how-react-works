---
sidebar_position: 2
---

# How `root.render()` works

To render a UI using React, you should perform the following as the very first steps:

- Create a `root` object using `createRoot`.
- Call the `root.render(ui)` function.

```tsx
import { App } from "./app";
import { createRoot } from "react-dom/client";

const container = document.getElementById("root");

// This is the first step
// highlight-next-line
const root = createRoot(container);

// Then, the second
// highlight-next-line
root.render(<App />);
```

This section is all about the `root.render` function (the second step).
We will see its signature and how it works under the hood.


## Definition
### Declaration

The fiber root `render` method is declared here 
[in `/packages/react-dom/src/client/ReactDOMRoot.js`](https://github.com/facebook/react/blob/80d9a40114bb43c07d021e8254790852f450bd2b/packages/react-dom/src/client/ReactDOMRoot.js#L102)

### Signature

The `render` method is defined as follows:

```tsx
function render(children: ReactNodeList): void {
  // [Not Native Code]
}
```

As opposed to what we mentally call this parameter the `app` or `ui`, in React
code it is referred as `children`, so let's stick to `children` ðŸ˜‰

The type of this parameter is `ReactNodeList`, [which is](https://github.com/facebook/react/blob/80d9a40114bb43c07d021e8254790852f450bd2b/packages/shared/ReactTypes.js#L22):

```tsx
type ReactNodeList = ReactEmpty | React$Node;

// where:
// highlight-next-line
type ReactEmpty = null | void | boolean;

// and
// highlight-next-line
type React$Node =
  | null
  | boolean
  | number
  | string
  | React$Element<any>
  | React$Portal
  | Iterable<React$Node>;

// where
// highlight-next-line
type React$Element<ElementType extends React$ElementType> = {
  ref: any,
  type: ElementType,
  key: React$Key | null,
  props: React$ElementProps<ElementType>,
}
```

Having this said, we can several things to the `render` method,
[such as the following](https://codesandbox.io/s/crazy-resonance-jph8kc?file=/src/index.js)
or any complex app you used before:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="html" label="index.html">

```html
    <body>
        <div id="root1"></div>
        <hr />
        <div id="root2"></div>
        <hr />
        <div id="root3"></div>
    </body>
```
  </TabItem>
  <TabItem value="js" label="index.js" default>

```tsx
import React, { createElement } from "react";
import { createRoot } from "react-dom/client";

createRoot(document.getElementById("root1")).render([
  "Hello ",
  <span key="world" style={{ color: "red" }}>
    World!
  </span>
]);

class ClassComponent extends React.Component {
  render() {
    const { initialCount } = this.props;

    return <p>Class Count is: {initialCount}</p>;
  }
}

createRoot(document.getElementById("root2")).render([
  <ul key="list">
    <li>First item</li>
    <li>Second</li>
    <li>Last, not third</li>
  </ul>,
  createElement(
    function FunctionComponent({ initialCount }) {
      return <span>Function Count is: {initialCount}</span>;
    },
    { initialCount: 2, key: "count" }
  ),
  <ClassComponent key="class" initialCount={3} />
]);

createRoot(document.getElementById("root3")).render([
  null,
  true,
  false,
  undefined
]);
```
  </TabItem>
</Tabs>

In a nutshell, you would pass a React Element or a collection of them.
React will then `render` them recursively and display your interactive UI.

## Implementation

Before diving in, make sure you've read the previous section about `createRoot`,
we will see many properties mentioned there.

### Purpose

The `render` method is used to inform React to start rendering your application.

### Implementation steps

As you may have noticed if you clicked on the implementation link, the top level
implementation of `render` would:

1. Throw if the `root._internalRoot (FiberRootNode)` is null, which means that
   the `root.unmount` was called (or done manually).
2. Perform some `__DEV__` mode checks and warnings:
   1. If you pass a second argument of type `function`, like the legacy
      `ReactDOM.render(children, callback)`.
   2. If you pass the `children` as a second argument, it guesses that you
      are using the legacy signature.
   3. If you pass anything as a second argument.
3. call `updateContainer(children, root, null, null)`.

```tsx
// simplified
ReactDOMRoot.prototype.render = function render(children: ReactNodeList): void {
    const root = this._internalRoot;
    if (root === null) {
      throw new Error('Cannot update an unmounted root.');
    }
    
    // dev checks
    
    updateContainer(children, root, null, null);
}
```


### `updateContainer`
`updateContainer` is a function called from many places in the React codebase,
you may be wondering why it is called `update` and not `render` or even `mount` ?
It is because for React all the work is done via this function, and if it
detects in a subtree that it is actually a `mount` it will do so.

It is important to analyze [this function:](https://github.com/facebook/react/blob/80d9a40114bb43c07d021e8254790852f450bd2b/packages/react-reconciler/src/ReactFiberReconciler.js#L318)

#### Signature

```tsx
export function updateContainer(
  element: ReactNodeList, // children
  container: OpaqueRoot, // OpaqueRoot = FiberRoot = new FiberRootNode
  parentComponent?: React$Component<any, any>,
  callback?: Function,
): Lane {
  // [Not Native Code]
}
```

This function does a lot of things, and is used now when `mounting` our tree
for the first time and later on updates.

The last two parameters were passed as `null` when coming from `root.render`,
which means that they aren't used. We will talk about them only when necessary
though.

1. **Reference the `current` attached `Fiber`**

   The `container` passed here isn't the same as the `DOMElement` you passed
   to `createRoot`. This one is the `root._internalRoot` which is a `FiberRootNode`.
   
   The `container.current` property is of type `FiberNode` if you remember from
   the previous blog, which is the very first `Fiber` you application created
   until now.

   ```tsx
   const current = container.current;
   ```

2. **Request an update Lane**

   The next thing React does is to request an update lane (a number) for the
   current `Fiber`:
   
   ```tsx
   const lane = requestUpdateLane(current);
   ```
   
   This is our first real `Lanes` encounter, so we've got to explain them
   briefly:
   
   A `lane` is a natural number whose value isn't important directly, it is
   manipulated using bitwise operators to combine several states into one number.
   They are defined [here in the React codebase](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L18).
   You can see the used lanes such as: `SyncLane`, `InputContinuousLane`,
   `IdleLane`, `OffscreenLane` and so on...

   So React will use these natural numbers with bitwise masks to detect the
   capabilities and behavior of any unit of work. We will be seing these Lanes
   all over again and again.

   The [`requestUpdateLane`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L606)
   will use the `fiber.mode` (from `FiberNode`) to infer the necessary update
   lane among other variables, this function is called on runtime too after
   the initial render, so we will go through it as is:

   - If the mode isn't concurrent (`(mode & ConcurrentMode) === NoMode`), then
     the `SyncLane`(`2`) is returned.
   - If it is a __render phase update__ (calling `setState` during render), then
     the [highest priority lane is returned](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L527):
     `lane & -lane` technically, which will be equal (generally) for a number n,
     to `n & -n = 2^k` where k is the position of the rightmost set bit in the
     binary representation of n. So we will refer to this gymnastic with
     `highestPriorityLane` in the future (or, the smallest `Lane` present
     in the given `Lanes` number).
     ```tsx
     // let say we have this arbitrary lanes number:
     // 0b000_1011_0000
     // the highest priotiry lane would be 0b000_0001_0000
     ```
     
      So, when updating a container from a render phase update, React will
      take the highest priority Lane (the lanes definitions are smartly ordered).
   - If the update occurs within a `Transition` (yes, you can do 
      `startTransition(() => { root.render(children); })`), then it will select
      from the `TransitionLanes` [defined here](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L52)
      and upgrade and/or reset the next transition [lane to claim](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L506).
   - If the global [`currentUpdatePriority`](https://github.com/facebook/react/blob/f101c2d0d3a6cb5a788a3d91faef48462e45f515/packages/react-reconciler/src/ReactEventPriorities.js#L29)
     is set and different from `NoLane` (`0`), then it will be returned.
   - If none of the previous conditions didn't match, React assumes that the
     update originated from outside React, and then will ask the `Host`
     environment to give `getCurrentEventPriority()`, which in our `DOM` case,
     will use `window.event` to infer [its priority.](https://github.com/facebook/react/blob/e50531692010bbda2a4627b07c7c810c3770a52a/packages/react-dom-bindings/src/client/ReactFiberConfigDOM.js#L597)

3. **Resolve and attach the subtree context**
   
   Next, React will infer and attach [`container(FiberRootNode).context`](https://github.com/facebook/react/blob/80d9a40114bb43c07d021e8254790852f450bd2b/packages/react-reconciler/src/ReactFiberReconciler.js#L334)
   if it is null, or attach to `container.pendingContext` if already defined.
   This context property is to be detailed later.

4. **Create an `update` Object**

   If you remember from the [previous chapter](/docs/react-dom/how.createroot.works#recap), 
   our `FiberNode` has an `UpdateQueue` that's used to collect `pending` updates,
   our first real `Update` object is [created here](https://github.com/facebook/react/blob/80d9a40114bb43c07d021e8254790852f450bd2b/packages/react-reconciler/src/ReactFiberReconciler.js#L358)
   for the given Lane:
     ```tsx
     // closure vars:
     // - element: chilren or ui, the node passed to root.render()
     // - callback: last parameter to updateContainer, null from root.render()
   
   
     // simplified
     const update = {
       lane,
       tag: UpdateState, // 0
       
       callback, // callback or null
       payload: {element}, // element are the root children
       
       next: null,
     };
     ```

5. **Enqueue the created update to the `Fiber`**

   At this point, we are aware of the `updateLane` and have created an `Update`
   to be applied on our `FiberRoot`, but not right away! React needs to
   properly schedule the processing of this update.

   To do so, the first step is to add this update to the queue:
   ```tsx
   const root: FiberRoot | null = enqueueUpdate(current, update, lane);
   
   // current: FiberNode
   // update: Update
   // lane: number (update lane)
   ```
   The returned `null` value may occur only if the current [fiber is unmounted.](https://github.com/facebook/react/blob/4bbac04cd3624962900bb7800ba4f9609d3a1fd3/packages/react-reconciler/src/ReactFiberClassUpdateQueue.js#L227)

    
   
   
   
6. **Schedule an update on the current `Fiber`**
7. **Entangle the `Fiber`'s transitions**

### Recap
